{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PICLE","text":"<p>PICLE builds interactive command-line shells from Pydantic v2 models. It uses Python\u2019s standard <code>cmd</code> loop under the hood and turns each entered line into a walk through a model tree:</p> <pre><code>Root model\n  \u251c\u2500 field -&gt; sub-model (becomes a command group)\n  \u251c\u2500 field -&gt; value (collects validated input)\n  \u2514\u2500 field -&gt; function (execute when ENTER is pressed)\n</code></pre> <p>What you get out of the box:</p> <ul> <li>Nested commands (models inside models)</li> <li>Validation and type conversion via Pydantic</li> <li>Inline discovery with <code>?</code> / <code>??</code> and tab completion</li> <li>Optional piping with <code>|</code> to post-process results</li> <li>Optional Rich/Tabulate/YAML output helpers (extras)</li> </ul> <p>Install:</p> <pre><code>pip install picle\n</code></pre> <p>A minimal example:</p> <pre><code>import time\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field\nfrom picle import App\n\n\nclass Show(BaseModel):\n    version: Any = Field(\n        None,\n        description=\"Show software version\",\n        json_schema_extra={\"function\": \"show_version\"},\n    )\n    clock: Any = Field(\n        None,\n        description=\"Show current clock\",\n        json_schema_extra={\"function\": \"show_clock\"},\n    )\n\n    @staticmethod\n    def show_version():\n        return \"0.1.0\"\n\n    @staticmethod\n    def show_clock():\n        return time.ctime()\n\n\nclass Root(BaseModel):\n    show: Show = Field(None, description=\"Show commands\")\n\n    class PicleConfig:\n        intro = \"PICLE sample app\"\n        prompt = \"picle#\"\n\n\nif __name__ == \"__main__\":\n    App(Root).start()\n</code></pre>"},{"location":"Getting%20Started/","title":"Getting Started","text":""},{"location":"Getting%20Started/#introducing-picle","title":"Introducing PICLE","text":"<p>Command-line interfaces are great when you want a fast workflow: type a command, get output, repeat. In practice, a good interactive shell also needs help, completion, and input validation.</p> <p>PICLE provides those features by turning Pydantic v2 models into an interactive shell. You define a model tree, and PICLE interprets the command line as a walk through that tree.</p> <p>At a high level, your shell looks like this:</p> <pre><code>Root\n  \u251c\u2500 command -&gt; SubModel\n  \u2502    \u251c\u2500 arg -&gt; Field (collect value)\n  \u2502    \u251c\u2500 flag -&gt; Field (presence)\n  \u2502    \u2514\u2500 &lt;ENTER&gt; -&gt; run() / field function\n  \u2514\u2500 command -&gt; Field (collect value)\n</code></pre> <p>Concretely: field names (or <code>alias</code> / <code>serialization_alias</code>) become command tokens. Tokens after a leaf field become that field\u2019s value(s). Once PICLE has enough information,  it validates the collected data with Pydantic and then executes your code.</p> <p>How a line is processed:</p> <pre><code>user input\n  -&gt; parse tokens into (models + fields)\n  -&gt; collect values (supports quotes, JSON-ish {..} / [..], multiline)\n  -&gt; validate with Pydantic\n  -&gt; execute (model.run or field function)\n  -&gt; processors / outputter\n  -&gt; print\n</code></pre>"},{"location":"Getting%20Started/#a-small-shell","title":"A small shell","text":"<p>This creates:</p> <pre><code>Root\n  \u2514\u2500 show\n    \u251c\u2500 version   (function)\n    \u2514\u2500 clock     (function)\n</code></pre> <pre><code>import time\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field\nfrom picle import App\n\n\nclass Show(BaseModel):\n  version: Any = Field(\n    None,\n    description=\"Show software version\",\n    json_schema_extra={\"function\": \"show_version\"},\n  )\n  clock: Any = Field(\n    None,\n    description=\"Show current clock\",\n    json_schema_extra={\"function\": \"show_clock\"},\n  )\n\n  @staticmethod\n  def show_version():\n    return \"0.1.0\"\n\n  @staticmethod\n  def show_clock():\n    return time.ctime()\n\n\nclass Root(BaseModel):\n  show: Show = Field(None, description=\"Show commands\")\n\n  class PicleConfig:\n    prompt = \"picle#\"\n    intro = \"PICLE Sample app\"\n\n\nif __name__ == \"__main__\":\n  App(Root).start()\n</code></pre> <p>Try it:</p> <pre><code>picle#show version\n0.1.0\npicle#show clock\nFri May  2 22:44:01 2025\n</code></pre>"},{"location":"Getting%20Started/#what-gets-executed","title":"What gets executed","text":"<p>PICLE decides what to call in this order:</p> <p>1) If the current model has a <code>run(**kwargs)</code> method, it calls <code>run</code>. 2) Otherwise, if the last referenced field has <code>json_schema_extra={\"function\": \"...\"}</code>, PICLE calls that model staticmethod.</p> <p>That keeps simple \u201ccommand -&gt; function\u201d shells small, while still supporting bigger models that centralize behavior in <code>run()</code>.</p>"},{"location":"Getting%20Started/#help-and-discovery","title":"Help and discovery","text":"<p>PICLE\u2019s help is model-driven:</p> <pre><code>picle#?\n... shows available top-level commands and built-in commands\n\npicle#show ?\n... shows available fields under \"show\"\n\npicle#show version ?\n... shows what ENTER will do\n</code></pre> <p>For a command tree view:</p> <pre><code>picle#man tree\n</code></pre> <p>For a JSON schema (useful if you want to expose your shell as documented data):</p> <pre><code>picle#man json-schema\n</code></pre>"},{"location":"Getting%20Started/#subshells-optional","title":"Subshells (optional)","text":"<p>If a model sets <code>PicleConfig.subshell = True</code>, you can \u201center\u201d that model as a subshell. When you navigate to the model without providing arguments, PICLE pushes it onto a shell stack and updates the prompt.</p> <p>Shell navigation commands:</p> <pre><code>exit   leave current subshell\ntop    return to the root shell\nend    exit the app\npwd    print current shell path\ncls    clear the screen\n</code></pre>"},{"location":"Getting%20Started/#pipes-optional","title":"Pipes (optional)","text":"<p>If the current model declares <code>PicleConfig.pipe</code>, the <code>|</code> token starts a new command segment. The second segment receives the previous segment\u2019s result as its first argument.</p> <pre><code>segment 0 (produce data)\n  | segment 1 (transform/format)\n  | segment 2 (transform/format)\n</code></pre> <p>PICLE includes a ready-to-use pipe model (<code>PipeFunctionsModel</code>) with filters and outputters.</p>"},{"location":"Getting%20Started/#configuration-shells-with-configmodel","title":"Configuration shells with <code>ConfigModel</code>","text":"<p>If you want a CLI that edits a structured YAML configuration, PICLE includes <code>picle.models.ConfigModel</code>. It lets users navigate a nested Pydantic model, stage edits into <code>&lt;config_file&gt;.tmp</code>, review diffs, and then commit.</p> <p>Minimal shape:</p> <pre><code>from pydantic import BaseModel, Field\nfrom picle import App\nfrom picle.models import ConfigModel, PipeFunctionsModel\n\n\nclass Logging(BaseModel):\n  severity: str = Field(None, description=\"Log severity\")\n\n\nclass MyConfig(ConfigModel):\n  logging: Logging = Field(None, description=\"Logging config\")\n\n  class PicleConfig:\n    subshell = True\n    prompt = \"app[cfg]#\"\n    config_file = \"app_config.yaml\"\n\n\nclass Root(BaseModel):\n  configure: MyConfig = Field(None, description=\"Edit configuration\")\n\n  class PicleConfig:\n    prompt = \"app#\"\n    pipe = PipeFunctionsModel\n\n\nif __name__ == \"__main__\":\n  App(Root).start()\n</code></pre> <p>Example interaction:</p> <pre><code>app#configure\napp[cfg]#logging severity debug\nConfiguration updated (uncommitted). Use 'commit' to save or 'show changes' to review.\n\napp[cfg]#show changes\n... unified diff ...\n\napp[cfg]#commit\nConfiguration committed successfully\n</code></pre> <p><code>ConfigModel</code> also honors a additional <code>PicleConfig</code> parameters:</p> <ul> <li><code>config_file</code>: YAML config path (default: <code>configuration.yaml</code>)</li> <li><code>backup_on_save</code>: number of rotating backups to keep on commit (default: 5)</li> <li><code>commit_hook</code>: optional callable executed after a successful commit</li> </ul> <p>Notes:</p> <ul> <li><code>show configuration</code> prints the running config, <code>show changes</code> prints the staged diff.</li> <li><code>clear-changes</code> discards the staged temp file; <code>erase-configuration</code> stages an empty config.</li> <li><code>rollback &lt;n&gt;</code> loads <code>app_config.yaml.old&lt;n&gt;</code> into the temp file for review/commit.</li> </ul>"},{"location":"Getting%20Started/#multi-line-input","title":"Multi-line input","text":"<p>If a field sets <code>json_schema_extra={\"multiline\": True}</code>, the user can type <code>input</code> as the value to start multi-line collection. PICLE reads lines until EOF (Ctrl+D), then joins them with newlines and validates the result.</p>"},{"location":"Getting%20Started/#sample-shell-apps","title":"Sample shell apps","text":"<p>If you want copy/paste starting points, the repository includes a couple of small runnable examples:</p> <ul> <li><code>test/docs_sample_app_1.py</code>: a tiny \u201cshow version/clock\u201d shell</li> <li><code>test/config_app_example.py</code>: a complete <code>ConfigModel</code> configuration shell example</li> </ul>"},{"location":"api_reference/","title":"PICLE API reference","text":"<p>This page describes the configuration hooks PICLE reads from your Pydantic models and fields. It focuses on the parts you use when defining a shell (config, field metadata, execution, and output). For full API docs of <code>App</code> and built-in models, keep reading to the mkdocstrings reference at the bottom.</p>"},{"location":"api_reference/#picleconfig-model-level-configuration","title":"<code>PicleConfig</code> Model Level Configuration","text":"<p>Any Pydantic model may define an inner <code>PicleConfig</code> class. PICLE reads attributes from it (when present). Only a few are required; most are optional quality-of-life switches.</p> <p><code>PicleConfig</code> is intentionally \u201copen-ended\u201d: the core <code>App</code> reads a known set of attributes (documented below), and specific built-in models may honor additional <code>PicleConfig</code> keys (for example, <code>ConfigModel</code>).</p> Name Meaning <code>ruler</code> Separator line char used by <code>cmd</code> help formatting (empty disables) <code>intro</code> Banner printed on shell start <code>prompt</code> Prompt string <code>use_rich</code> If <code>True</code> and Rich is installed, print via Rich console <code>newline</code> Output newline, default <code>\\r\\n</code> <code>completekey</code> Readline completion key name, default <code>tab</code> <code>pipe</code> Enables <code>|</code> and selects the pipe model (<code>\"self\"</code>, import string, or model class) <code>processors</code> List of callables applied to the first command result <code>outputter</code> Callable used to render output when not overridden <code>outputter_kwargs</code> Extra kwargs passed into <code>outputter</code> <code>history_length</code> Length of commands history to store for <code>history</code> output, default 100 <code>history_file</code> Filename to persistently store commands history, default <code>./picle_history.txt</code> <code>subshell</code> If <code>True</code>, navigating to this model with no args enters a subshell (prompt changes, model is pushed onto a stack) <code>methods_override</code> Dict of <code>{app_method_name: model_method_name}</code> used to override <code>App</code> methods at runtime"},{"location":"api_reference/#json_schema_extra-field-level-configuration","title":"<code>json_schema_extra</code> Field Level Configuration","text":"<p>PICLE reads extra behavior from fields definitions - <code>Field(..., json_schema_extra={...})</code>.</p> <p>Note: command tokens come from the field name (or its <code>alias</code> / <code>serialization_alias</code>), not from the Pydantic class name.</p> Key Meaning <code>function</code> Name of a model <code>@staticmethod</code> to call when <code>run()</code> is absent <code>presence</code> Constant value used when field is referenced without a value <code>processors</code> List of callables applied to the command result <code>outputter</code> Callable that formats output for this field (overrides model outputter) <code>outputter_kwargs</code> Extra kwargs passed into <code>outputter</code> <code>multiline</code> If <code>True</code>, the literal value <code>input</code> triggers multi-line collection <code>root_model</code> If <code>True</code>, pass the app root model as <code>root_model=...</code> <code>picle_app</code> If <code>True</code>, pass the <code>App</code> instance as <code>picle_app=...</code> <code>use_parent_run</code> If <code>True</code> (default), and the leaf model has no <code>run()</code>, PICLE searches parent models for a <code>run()</code> to execute. If <code>False</code>, the command errors unless the leaf model defines <code>run()</code> or <code>function</code>. <code>pkey</code> Primary key name to use for dynamic dictionary models <code>pkey_description</code> Description of dynamic dictionary model primary key"},{"location":"api_reference/#handling-of-function-argument-vs-run-method","title":"Handling of <code>function</code> Argument vs <code>run()</code> Method","text":"<p>Execution is resolved like this:</p> <ol> <li>If the last referenced field sets <code>json_schema_extra={\"function\": \"method_name\"}</code>, PICLE calls <code>getattr(model, method_name)(**kwargs)</code>.</li> <li>If the current model has <code>run</code>, PICLE calls <code>model.run(**kwargs)</code>.</li> <li>if <code>json_schema_extra={\"use_parent_run\": True}</code> set on the field, backtracks parent models and executes first found <code>run()</code> method.</li> </ol> <p>This lets small models define many \u201ccommand -&gt; staticmethod\u201d fields, while larger models can centralize behavior in <code>run()</code>.</p>"},{"location":"api_reference/#callable-signatures","title":"Callable Signatures","text":"<p>PICLE builds callable <code>**kwargs</code> from collected field values and calls either <code>run()</code> or the field-level <code>function</code>. It can also inject extra context if callable declares a matching argument name:</p> <ul> <li><code>root_model</code> - if callable signature includes <code>root_model</code> adds <code>self.root</code> model to callable arguments e.g. <code>root_model=self.root</code></li> <li><code>picle_app</code> - if callable signature includes <code>picle_app</code> adds <code>self</code> to callable arguments e.g. <code>picle_app=self</code></li> <li><code>shell_command</code> - if callable signature includes <code>shell_command</code> adds parsed command context for the current segment: a list of model dictionaries produced by <code>parse_command</code> method. This is useful when your function needs to inspect the command path, model defaults, or other parsing details.</li> </ul>"},{"location":"api_reference/#picle-app","title":"PICLE App","text":""},{"location":"api_reference/#picle.App","title":"<code>picle.App(root: object, stdin=None, stdout=None)</code>","text":"<p>               Bases: <code>Cmd</code></p> <p>PICLE App class to construct shell.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>object</code>)           \u2013            <p>Root/Top Pydantic model.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def __init__(self, root: object, stdin=None, stdout=None):\n    self.root = root\n    self.shell = self.root.model_construct()\n    self.shell_defaults = {}\n    self.shells = [self.shell]\n\n    # extract configuration from shell model\n    if hasattr(self.shell, \"PicleConfig\"):\n        self.ruler = getattr(self.shell.PicleConfig, \"ruler\", self.ruler)\n        self.intro = getattr(self.shell.PicleConfig, \"intro\", self.intro)\n        self.prompt = getattr(self.shell.PicleConfig, \"prompt\", self.prompt)\n        self.newline = getattr(self.shell.PicleConfig, \"newline\", self.newline)\n        self.use_rich = getattr(self.shell.PicleConfig, \"use_rich\", self.use_rich)\n        self.completekey = getattr(\n            self.shell.PicleConfig, \"completekey\", self.completekey\n        )\n        self.history_length = getattr(\n            self.shell.PicleConfig, \"history_length\", self.history_length\n        )\n        self.history_file = getattr(\n            self.shell.PicleConfig, \"history_file\", self.history_file\n        )\n\n        # mount override methods\n        if hasattr(self.shell.PicleConfig, \"methods_override\"):\n            for (\n                method_name,\n                override,\n            ) in self.shell.PicleConfig.methods_override.items():\n                setattr(self, method_name, getattr(self.shell, override))\n\n    # mount models\n    self.model_mount(MAN, [\"man\"], \"Manual/documentation functions\")\n\n    super(App, self).__init__(stdin=stdin, stdout=stdout)\n\n    # configure readline history\n    if HAS_READLINE:\n        _readline.set_history_length(self.history_length)\n        if self.history_file:\n            history_path = os.path.expanduser(self.history_file)\n            if os.path.exists(history_path):\n                try:\n                    _readline.read_history_file(history_path)\n                except OSError:\n                    pass\n</code></pre>"},{"location":"api_reference/#picle.App.build_command_data","title":"<code>picle.App.build_command_data(models: list) -&gt; dict</code>","text":"<p>Build flat dictionary of command data from parsed models list.</p> <p>Parameters:</p> <ul> <li> <code>models</code>               (<code>list</code>)           \u2013            <p>List of parsed model dictionaries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Flat dictionary of command data.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def build_command_data(self, models: list) -&gt; dict:\n    \"\"\"\n    Build flat dictionary of command data from parsed models list.\n\n    Args:\n        models (list): List of parsed model dictionaries.\n\n    Returns:\n        dict: Flat dictionary of command data.\n    \"\"\"\n    command_data = {}\n    for index, model in enumerate(models):\n        # collect data for dynamic dictionary keys\n        if isinstance(model[\"model\"], VirtualDictModel):\n            vdm = model[\"model\"]\n            # collect next model parameter as a value for the dictionary key\n            command_data[vdm.key] = models[index + 1][\"parameter\"]\n        else:\n            for f in model[\"fields\"]:\n                if f[\"values\"] is not ...:\n                    command_data[f[\"name\"]] = f[\"values\"]\n    return command_data\n</code></pre>"},{"location":"api_reference/#picle.App.completedefault","title":"<code>picle.App.completedefault(text: str, line: str, begidx: int, endidx: int) -&gt; list[str]</code>","text":"<p>Return completions for every command parameter after the first one.</p> <p>Called by cmd on a tab-key hit for arguments beyond the initial command keyword.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The current text being completed.</p> </li> <li> <code>line</code>               (<code>str</code>)           \u2013            <p>The current input line.</p> </li> <li> <code>begidx</code>               (<code>int</code>)           \u2013            <p>The beginning index of the completion.</p> </li> <li> <code>endidx</code>               (<code>int</code>)           \u2013            <p>The ending index of the completion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of completion suggestions.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def completedefault(\n    self, text: str, line: str, begidx: int, endidx: int\n) -&gt; list[str]:\n    \"\"\"\n    Return completions for every command parameter after the first one.\n\n    Called by cmd on a tab-key hit for arguments beyond the initial command keyword.\n\n    Args:\n        text (str): The current text being completed.\n        line (str): The current input line.\n        begidx (int): The beginning index of the completion.\n        endidx (int): The ending index of the completion.\n\n    Returns:\n        list[str]: List of completion suggestions.\n    \"\"\"\n    fieldnames = []\n    try:\n        command_models = self.parse_command(line, is_help=True)\n        last_model = command_models[-1][-1][\"model\"]\n        # check if last model has fields collected\n        if command_models[-1][-1][\"fields\"]:\n            last_field_name = command_models[-1][-1][\"fields\"][-1][\"name\"]\n            last_field = model_fields(last_model)[last_field_name]\n            last_field_value = command_models[-1][-1][\"fields\"][-1][\"values\"]\n            fparam = self._get_field_params(last_field)\n            if isinstance(last_field_value, list):\n                last_field_value = last_field_value[-1]\n            elif last_field_value == ...:\n                last_field_value = \"\"\n            # check if need to extract enum values\n            if isinstance(last_field.annotation, enum.EnumMeta):\n                fieldnames = [\n                    str(i.value)\n                    for i in last_field.annotation\n                    if str(i.value).startswith(last_field_value)\n                    and i.value != last_field_value\n                ]\n            # check if model has method to source field choices\n            elif hasattr(last_model, f\"source_{last_field_name}\"):\n                fieldnames = getattr(last_model, f\"source_{last_field_name}\")()\n                # handle partial match\n                if last_field_value not in fieldnames:\n                    fieldnames = [\n                        str(i)\n                        for i in fieldnames\n                        if str(i).startswith(last_field_value)\n                    ]\n                # remove already collected values from choice\n                collected_values = command_models[-1][-1][\"fields\"][-1][\"values\"]\n                if collected_values is not ...:\n                    fieldnames = [\n                        i for i in fieldnames if i not in collected_values\n                    ]\n            # auto complete 'load-terminal' for multi-line input mode\n            elif fparam.get(\"multiline\") is True:\n                if (\n                    \"load-terminal\".startswith(last_field_value)\n                    and last_field_value != \"load-terminal\"\n                ):\n                    fieldnames = [\"load-terminal\"]\n        # return a list of all model fields\n        else:\n            if line.endswith(\" \"):\n                for name, f in model_fields(last_model).items():\n                    if f.alias:\n                        fieldnames.append(f.alias)\n                    elif f.serialization_alias:\n                        fieldnames.append(f.serialization_alias)\n                    else:\n                        fieldnames.append(name)\n            else:\n                last_fieldname = command_models[-1][-1][\"parameter\"]\n                fieldnames.append(last_fieldname)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        for name, f in model_fields(model[\"model\"]).items():\n            # skip fields with already collected values from complete prompt\n            if any(\n                collected_field[\"name\"] == name\n                for collected_field in model[\"fields\"]\n                if collected_field[\"values\"] is not ...\n            ):\n                continue\n            # handle Enum fields options\n            elif any(\n                collected_field[\"name\"] == name\n                for collected_field in model[\"fields\"]\n            ) and isinstance(f.annotation, enum.EnumMeta):\n                fieldnames = [\n                    str(i.value)\n                    for i in f.annotation\n                    if str(i.value).startswith(parameter)\n                ]\n                break\n            elif f.alias and f.alias.startswith(parameter):\n                fieldnames.append(f.alias)\n            elif f.serialization_alias and f.serialization_alias.startswith(\n                parameter\n            ):\n                fieldnames.append(f.serialization_alias)\n            elif name.startswith(parameter):\n                fieldnames.append(name)\n    except FieldKeyError:\n        pass\n    except:\n        tb = traceback.format_exc()\n        self.write(tb)\n\n    return sorted([f\"{i} \" for i in fieldnames])\n</code></pre>"},{"location":"api_reference/#picle.App.completenames","title":"<code>picle.App.completenames(text: str, line: str, begidx: int, endidx: int) -&gt; list[str]</code>","text":"<p>Return completions for the very first command parameter.</p> <p>Called by cmd on a tab-key hit for the initial keyword.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The current text being completed.</p> </li> <li> <code>line</code>               (<code>str</code>)           \u2013            <p>The current input line.</p> </li> <li> <code>begidx</code>               (<code>int</code>)           \u2013            <p>The beginning index of the completion.</p> </li> <li> <code>endidx</code>               (<code>int</code>)           \u2013            <p>The ending index of the completion.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of completion suggestions.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def completenames(\n    self, text: str, line: str, begidx: int, endidx: int\n) -&gt; list[str]:\n    \"\"\"\n    Return completions for the very first command parameter.\n\n    Called by cmd on a tab-key hit for the initial keyword.\n\n    Args:\n        text (str): The current text being completed.\n        line (str): The current input line.\n        begidx (int): The beginning index of the completion.\n        endidx (int): The ending index of the completion.\n\n    Returns:\n        list[str]: List of completion suggestions.\n    \"\"\"\n    fieldnames = []\n    # collect global methods\n    for method_name in dir(self):\n        if method_name.startswith(\"do_\"):\n            name = method_name.replace(\"do_\", \"\")\n            if name.startswith(line):\n                fieldnames.append(name)\n    # collect model arguments\n    try:\n        command_models = self.parse_command(line, is_help=True)\n        fieldnames.extend(model_fields(command_models[-1][-1][\"model\"]))\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        for name, f in model_fields(model[\"model\"]).items():\n            display = f.alias or f.serialization_alias or name\n            if display.startswith(parameter):\n                fieldnames.append(display)\n    except FieldKeyError:\n        pass\n    return sorted([f\"{i} \" for i in fieldnames])\n</code></pre>"},{"location":"api_reference/#picle.App.default","title":"<code>picle.App.default(line: str) -&gt; Optional[bool]</code>","text":"<p>Process a command line when no matching do_* method is found.</p> <p>Parameters:</p> <ul> <li> <code>line</code>               (<code>str</code>)           \u2013            <p>Command line input.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[bool]</code>           \u2013            <p>Optional[bool]: True if the shell should exit, otherwise None.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>@run_print_exception\ndef default(self, line: str) -&gt; Optional[bool]:\n    \"\"\"\n    Process a command line when no matching do_* method is found.\n\n    Args:\n        line (str): Command line input.\n\n    Returns:\n        Optional[bool]: True if the shell should exit, otherwise None.\n    \"\"\"\n    ret = False\n    outputter = True  # use default outputter - self.write\n    outputter_kwargs = {}\n    line = line.strip()\n\n    if line.endswith(\"?\"):\n        self.process_help_command(line)\n    else:\n        try:\n            command_models = self.parse_command(line, collect_multiline=True)\n        except FieldLooseMatchOnly as e:\n            model, parameter = e.args\n            fields = [\n                f.alias or f.serialization_alias or name\n                for name, f in model_fields(model[\"model\"]).items()\n                if name.startswith(parameter)\n                or (f.alias and f.alias.startswith(parameter))\n                or (\n                    f.serialization_alias\n                    and f.serialization_alias.startswith(parameter)\n                )\n            ]\n            self.write_error(\n                f\"Incomplete command, possible completions: {', '.join(fields)}\"\n            )\n        except FieldKeyError as e:\n            model, parameter = e.args\n            candidates = [\n                f.alias or f.serialization_alias or name\n                for name, f in model_fields(model[\"model\"]).items()\n            ]\n            close = difflib.get_close_matches(\n                parameter, candidates, n=3, cutoff=0.6\n            )\n            msg = f\"Incorrect command, '{parameter}' not part of '{self._get_model_name(model)}' model fields\"\n            if close:\n                msg += f\". Did you mean: {', '.join(close)}?\"\n            self.write_error(msg)\n        except ValidationError as e:\n            self.write_error(e)\n        else:\n            # go over collected commands separated by pipe\n            for index, command in enumerate(command_models):\n                json_schema_extra = {}\n                method_name = None\n                # collect arguments\n                command_arguments = self.build_command_data(command)\n\n                # collect command defaults\n                command_defaults = {}\n                for cmd in command:\n                    command_defaults.update(cmd.get(\"defaults\", {}))\n                model = command[-1][\"model\"]\n                picle_config = getattr(model, \"PicleConfig\", None)\n\n                # check if model has subshell and no arguments provided - enter subshell\n                if (\n                    not command_arguments\n                    and getattr(picle_config, \"subshell\", None) is True\n                ):\n                    for item in command[:-1]:\n                        m = item[\"model\"]\n                        self.defaults_update(m)\n                        if (\n                            getattr(\n                                getattr(m, \"PicleConfig\", None), \"subshell\", None\n                            )\n                            is True\n                            and m not in self.shells\n                        ):\n                            self.shells.append(m)\n                    self.prompt = getattr(picle_config, \"prompt\", self.prompt)\n                    self.shell = model\n                    self.shells.append(self.shell)\n                    continue\n\n                # resolve run function - prefer json_schema_extra \"function\", fallback to \"run\" method, search parents for \"run\"\n                if command[-1][\"fields\"]:\n                    json_schema_extra = command[-1][\"fields\"][-1][\n                        \"json_schema_extra\"\n                    ]\n                if callable(json_schema_extra.get(\"function\")):\n                    run_function = json_schema_extra[\"function\"]\n                else:\n                    method_name = json_schema_extra.get(\"function\", \"run\")\n                    if hasattr(model, method_name):\n                        run_function = getattr(model, method_name)\n                    elif method_name != \"run\":\n                        ret = f\"Model '{model.__name__}' has no '{method_name}' method defined\"\n                        break\n                    elif json_schema_extra.get(\"use_parent_run\", True):\n                        run_function = self._find_parent_run(command)\n                        if run_function is None:\n                            self.defaults_pop(model)\n                            ret = f\"Incorrect command for '{model.__name__}', model parents have no 'run' method to execute command\"\n                            break\n                    else:\n                        self.defaults_pop(model)\n                        ret = f\"Incorrect command for '{model.__name__}', model has no method to execute command\"\n                        break\n\n                # validate command data and exit if failed\n                if not self._validate_values(command):\n                    return\n\n                # build kwargs and call the method\n                kw = {}\n                if callable_expects_argument(run_function, \"shell_command\"):\n                    kw[\"shell_command\"] = command\n                if callable_expects_argument(run_function, \"root_model\"):\n                    kw[\"root_model\"] = self.root\n                if callable_expects_argument(run_function, \"picle_app\"):\n                    kw[\"picle_app\"] = self\n                if index == 0:\n                    kw.update(self.shell_defaults)\n                    kw.update(command_defaults)\n                    kw.update(command_arguments)\n                    ret = run_function(**kw)\n                else:\n                    kw.update(command_defaults)\n                    kw.update(command_arguments)\n                    ret = run_function(ret, **kw)\n\n                # apply field-level processors\n                for processor in json_schema_extra.get(\"processors\", []):\n                    if callable(processor):\n                        ret = processor(ret)\n\n                # apply PicleConfig processors for first command only\n                if index == 0:\n                    for processor in getattr(picle_config, \"processors\", []):\n                        if callable(processor):\n                            ret = processor(ret)\n\n                # resolve outputter: from return tuple, field definition, or PicleConfig\n                if isinstance(ret, tuple) and len(ret) == 2:\n                    ret, outputter = ret\n                    outputter_kwargs = {}\n                elif isinstance(ret, tuple) and len(ret) == 3:\n                    ret, outputter, outputter_kwargs = ret\n                elif json_schema_extra.get(\"outputter\"):\n                    outputter = json_schema_extra[\"outputter\"]\n                    outputter_kwargs = json_schema_extra.get(\"outputter_kwargs\", {})\n                elif picle_config and hasattr(picle_config, \"outputter\"):\n                    outputter = picle_config.outputter\n                    outputter_kwargs = getattr(picle_config, \"outputter_kwargs\", {})\n\n    # returning True will end the shell - exit\n    if ret is True:\n        return True\n\n    if ret:\n        if callable(outputter):\n            self.write(outputter(ret, **outputter_kwargs))\n        elif outputter is True:\n            self.write(ret)\n</code></pre>"},{"location":"api_reference/#picle.App.defaults_pop","title":"<code>picle.App.defaults_pop(model: Any) -&gt; None</code>","text":"<p>Remove the given model's field names from shell_defaults.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def defaults_pop(self, model: Any) -&gt; None:\n    \"\"\"\n    Remove the given model's field names from shell_defaults.\n\n    Args:\n        model: Pydantic model class or instance.\n    \"\"\"\n    for name in model_fields(model).keys():\n        self.shell_defaults.pop(name, None)\n</code></pre>"},{"location":"api_reference/#picle.App.defaults_set","title":"<code>picle.App.defaults_set(model: Any) -&gt; None</code>","text":"<p>Replace shell_defaults with the given model's defaults.</p> <p>Clears the existing defaults and populates them from model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def defaults_set(self, model: Any) -&gt; None:\n    \"\"\"\n    Replace shell_defaults with the given model's defaults.\n\n    Clears the existing defaults and populates them from model.\n\n    Args:\n        model: Pydantic model class or instance.\n    \"\"\"\n    self.shell_defaults.clear()\n    self.defaults_update(model)\n</code></pre>"},{"location":"api_reference/#picle.App.defaults_update","title":"<code>picle.App.defaults_update(model: Any) -&gt; None</code>","text":"<p>Merge the given model's default field values into shell_defaults.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def defaults_update(self, model: Any) -&gt; None:\n    \"\"\"\n    Merge the given model's default field values into shell_defaults.\n\n    Args:\n        model: Pydantic model class or instance.\n    \"\"\"\n    self.shell_defaults.update(self.extract_model_defaults(model))\n</code></pre>"},{"location":"api_reference/#picle.App.do_cls","title":"<code>picle.App.do_cls(arg: str) -&gt; None</code>","text":"<p>Clear the terminal screen.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_cls(self, arg: str) -&gt; None:\n    \"\"\"Clear the terminal screen.\"\"\"\n    if \"?\" in arg:\n        self.write(\" cls    Clear shell Screen\")\n    else:\n        if \"LINUX\" in platform.system().upper():\n            os.system(\"clear\")\n        elif \"WINDOWS\" in platform.system().upper():\n            os.system(\"cls\")\n</code></pre>"},{"location":"api_reference/#picle.App.do_end","title":"<code>picle.App.do_end(arg: str) -&gt; Optional[bool]</code>","text":"<p>Exit the application entirely.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_end(self, arg: str) -&gt; Optional[bool]:\n    \"\"\"Exit the application entirely.\"\"\"\n    if \"?\" in arg:\n        self.write(\" end    Exit application\")\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/#picle.App.do_exit","title":"<code>picle.App.do_exit(arg: str) -&gt; Optional[bool]</code>","text":"<p>Exit current shell or terminate if at the top level.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_exit(self, arg: str) -&gt; Optional[bool]:\n    \"\"\"Exit current shell or terminate if at the top level.\"\"\"\n    if \"?\" in arg:\n        self.write(\" exit    Exit current shell\")\n    else:\n        # delete defaults for closing shell\n        self.defaults_pop(self.shells[-1])\n        _ = self.shells.pop(-1)\n        if self.shells:\n            self.shell = self.shells[-1]\n            if hasattr(self.shell, \"PicleConfig\") and getattr(\n                self.shell.PicleConfig, \"prompt\"\n            ):\n                self.prompt = self.shell.PicleConfig.prompt\n            if len(self.shells) == 1:  # check if reached top shell\n                self.defaults_set(self.shell)\n        else:\n            return True\n</code></pre>"},{"location":"api_reference/#picle.App.do_help","title":"<code>picle.App.do_help(arg: str) -&gt; None</code>","text":"<p>Print help message for the given command or model.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_help(self, arg: str) -&gt; None:\n    \"\"\"Print help message for the given command or model.\"\"\"\n    try:\n        command_models = self.parse_command(arg.strip(\"?\"), is_help=True)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        self.print_model_help([[model]], verbose=..., match=parameter)\n        return\n    except FieldKeyError as e:\n        model, parameter = e.args\n        self.write_error(\n            f\"Incorrect command, '{parameter}' not part of \"\n            f\"'{self._get_model_name(model)}' model fields\"\n        )\n        return\n    help_msg, width = self.print_model_help(\n        command_models,\n        verbose=arg.strip().endswith(\"?\"),\n        print_help=False,\n    )\n    # print help for global top commands\n    if len(arg.strip().split(\" \")) == 1:\n        lines = {}  # dict of {cmd: cmd_help}\n        for method_name in dir(self):\n            if method_name.startswith(\"do_\"):\n                name = method_name.replace(\"do_\", \"\")\n                lines[name] = getattr(self, method_name).__doc__\n                width = max(width, len(name))\n        if lines:\n            for k, v in lines.items():\n                padding = \" \" * (width - len(k)) + (\" \" * 4)\n                help_msg.append(f\" {k}{padding}{v}\")\n    self.write(self.newline.join(help_msg))\n</code></pre>"},{"location":"api_reference/#picle.App.do_history","title":"<code>picle.App.do_history(arg: str) -&gt; None</code>","text":"<p>Print command history.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_history(self, arg: str) -&gt; None:\n    \"\"\"Print command history.\"\"\"\n    if \"?\" in arg:\n        self.write(\" history    Print command history\")\n    else:\n        if HAS_READLINE:\n            count = _readline.get_current_history_length()\n            if count == 0:\n                self.write(\"No command history\")\n            else:\n                lines = []\n                for i in range(count):\n                    if _readline.get_history_item(i + 1):\n                        line = f\" {_readline.get_history_item(i + 1).strip()}\"\n                        if line.strip() in [\"history\", \"exit\", \"top\", \"pwd\", \"end\", \"cls\", \"help\"]:\n                            continue\n                        if line.endswith(\"?\"):\n                            continue           \n                        if line in lines:\n                            continue\n                        lines.append(line)\n                self.write(self.newline.join(lines))\n        else:\n            self.write(\"No command history\")\n</code></pre>"},{"location":"api_reference/#picle.App.do_pwd","title":"<code>picle.App.do_pwd(arg: str) -&gt; None</code>","text":"<p>Print the current shell path from root.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_pwd(self, arg: str) -&gt; None:\n    \"\"\"Print the current shell path from root.\"\"\"\n    if \"?\" in arg:\n        self.write(\" pwd    Print current shell path\")\n    else:\n        path = [\"Root\"]\n        for shell in self.shells[1:]:\n            path.append(shell.__name__)\n        self.write(\"-&gt;\".join(path))\n</code></pre>"},{"location":"api_reference/#picle.App.do_top","title":"<code>picle.App.do_top(arg: str) -&gt; None</code>","text":"<p>Exit to top shell, resetting the shell stack.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_top(self, arg: str) -&gt; None:\n    \"\"\"Exit to top shell, resetting the shell stack.\"\"\"\n    if \"?\" in arg:\n        self.write(\" top    Exit to top shell\")\n    else:\n        self.shell = self.shells[0]\n        if hasattr(self.shell, \"PicleConfig\") and getattr(\n            self.shell.PicleConfig, \"prompt\"\n        ):\n            self.prompt = self.shell.PicleConfig.prompt\n        while self.shells:\n            _ = self.shells.pop()\n        self.shells.append(self.shell)\n        # set shell defaults\n        self.defaults_set(self.shell)\n</code></pre>"},{"location":"api_reference/#picle.App.emptyline","title":"<code>picle.App.emptyline() -&gt; None</code>","text":"<p>Override empty line method to not run last command.</p> Source code in <code>picle\\picle.py</code> <pre><code>def emptyline(self) -&gt; None:\n    \"\"\"\n    Override empty line method to not run last command.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api_reference/#picle.App.extract_model_defaults","title":"<code>picle.App.extract_model_defaults(model: Any) -&gt; dict</code>","text":"<p>Extract non-None default values from a Pydantic model's fields.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance to extract defaults from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Dictionary mapping field names to their default values.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def extract_model_defaults(self, model: Any) -&gt; dict:\n    \"\"\"\n    Extract non-None default values from a Pydantic model's fields.\n\n    Args:\n        model: Pydantic model class or instance to extract defaults from.\n\n    Returns:\n        dict: Dictionary mapping field names to their default values.\n    \"\"\"\n    ret = {}\n    # extract default values from model fields\n    for name, field in model_fields(model).items():\n        # skip non Field references e.g. to other models\n        if not isinstance(field, FieldInfo):\n            continue\n        # skip required Fields\n        if field.is_required():\n            continue\n        # ignore None default values\n        if field.get_default() is None:\n            continue\n        default = field.get_default()\n        # convert Enum defaults to their plain value\n        if isinstance(default, enum.Enum):\n            default = default.value\n        ret[name] = default\n\n    return ret\n</code></pre>"},{"location":"api_reference/#picle.App.model_mount","title":"<code>picle.App.model_mount(model: ModelMetaclass, path: Union[str, list[str]], description: str = None, default: Any = None, **kwargs: dict) -&gt; None</code>","text":"<p>Mount a Pydantic model at the provided path in relation to the root model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>ModelMetaclass</code>)           \u2013            <p>Pydantic model to mount.</p> </li> <li> <code>path</code>               (<code>Union[str, list[str]]</code>)           \u2013            <p>List of path segments to mount the model.</p> </li> <li> <code>description</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Description of the model.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Default value for the model.</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the FieldInfo.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def model_mount(\n    self,\n    model: ModelMetaclass,\n    path: Union[str, list[str]],\n    description: str = None,\n    default: Any = None,\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"\n    Mount a Pydantic model at the provided path in relation to the root model.\n\n    Args:\n        model: Pydantic model to mount.\n        path: List of path segments to mount the model.\n        description (str, optional): Description of the model.\n        default: Default value for the model.\n        **kwargs: Additional keyword arguments for the FieldInfo.\n    \"\"\"\n    if isinstance(path, str):\n        path = [path.strip()]\n    parent_model = self.root\n    while path:\n        mount_name = path.pop(0)\n        if mount_name in parent_model.model_fields:\n            parent_model = parent_model.model_fields[mount_name].annotation\n        else:\n            # handle when not all path items before last one are in models tree\n            if len(path) &gt; 0:\n                raise KeyError(\n                    f\"'{mount_name}' not part of '{parent_model}' model fields, but remaining path still not empty - {path}\"\n                )\n            parent_model.model_fields[mount_name] = FieldInfo(\n                annotation=model,\n                required=False,\n                description=description,\n                default=default,\n                **kwargs,\n            )\n            break\n</code></pre>"},{"location":"api_reference/#picle.App.model_remove","title":"<code>picle.App.model_remove(path: list[str]) -&gt; None</code>","text":"<p>Remove a Pydantic model at the provided path in relation to the root model.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>list[str]</code>)           \u2013            <p>List of path segments to remove the model.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def model_remove(self, path: list[str]) -&gt; None:\n    \"\"\"\n    Remove a Pydantic model at the provided path in relation to the root model.\n\n    Args:\n        path (list[str]): List of path segments to remove the model.\n    \"\"\"\n    if isinstance(path, str):\n        path = [path.strip()]\n    parent_model = self.root\n    while path:\n        mount_name = path.pop(0)\n        if mount_name in parent_model.model_fields:\n            if len(path) == 0:\n                parent_model = parent_model.model_fields.pop(mount_name)\n            else:\n                parent_model = parent_model.model_fields[mount_name].annotation\n        else:\n            raise KeyError(\n                f\"Failed to remove model at path '{mount_name}', parent model: '{parent_model}'\"\n            )\n</code></pre>"},{"location":"api_reference/#picle.App.parse_command","title":"<code>picle.App.parse_command(command: str, collect_multiline: bool = False, is_help: bool = False) -&gt; list</code>","text":"<p>Parse command string and construct list of model references and field values.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>Command string to parse through.</p> </li> <li> <code>collect_multiline</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enables multiple input collection for fields.</p> </li> <li> <code>is_help</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicates that parsing help command or tab completion command; if set to True disables 'presence' argument handling for last field.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>List of lists of dictionaries with collected models details, each dictionary containing 'model', 'fields', and 'parameter' keys.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def parse_command(\n    self, command: str, collect_multiline: bool = False, is_help: bool = False\n) -&gt; list:\n    \"\"\"\n    Parse command string and construct list of model references and field values.\n\n    Args:\n        command (str): Command string to parse through.\n        collect_multiline (bool): Enables multiple input collection for fields.\n        is_help (bool): Indicates that parsing help command or tab completion command; if set to True disables 'presence' argument handling for last field.\n\n    Returns:\n        list: List of lists of dictionaries with collected models details, each dictionary containing 'model', 'fields', and 'parameter' keys.\n    \"\"\"\n    current_model = {\n        \"model\": self.shell,\n        \"fields\": [],\n        \"parameter\": ...,\n        \"defaults\": self.extract_model_defaults(self.shell),\n    }\n    current_field = {}\n    models = [current_model]\n    parameters = [i for i in command.split(\" \") if i.strip()]\n    ret = [models]\n\n    # iterate over command parameters and decide if its a reference\n    # to a model or model's field value\n    while parameters:\n        parameter = parameters.pop(0)\n\n        # handle pipe - \"|\"\n        if parameter == \"|\":\n            pipe_config = getattr(\n                getattr(current_model[\"model\"], \"PicleConfig\", None),\n                \"pipe\",\n                None,\n            )\n            if not pipe_config:\n                log.error(\n                    f\"'{current_model['model'].__name__}' does not support pipe handling\"\n                )\n                break\n            # resolve pipe model\n            if pipe_config == \"self\":\n                pipe_model = current_model[\"model\"]\n            # import pipe model from module path string\n            elif isinstance(pipe_config, str):\n                # rpartition - returns a tuple of (before_last_dot, dot, after_last_dot)\n                module_path, _, class_name = pipe_config.rpartition(\".\")\n                module = __import__(module_path, fromlist=[\"\"])\n                pipe_model = getattr(module, class_name)\n            else:\n                pipe_model = pipe_config\n            current_model = {\n                \"model\": pipe_model,\n                \"fields\": [],\n                \"parameter\": parameter,\n            }\n            models = [current_model]\n            ret.append(models)\n\n        # collect JSON dictionary or list string\n        elif parameter.strip().startswith((\"{\", \"[\")) and current_field:\n            close = \"}\" if parameter.strip().startswith(\"{\") else \"]\"\n            value_items = [parameter]\n            while parameters:\n                parameter = parameters.pop(0)\n                value_items.append(parameter)\n                if parameter.strip().endswith(close):\n                    break\n            self._save_collected_value(current_field, \" \".join(value_items))\n\n        # collect quoted field value (single or double quotes)\n        elif ('\"' in parameter or \"'\" in parameter) and current_field:\n            quote = '\"' if '\"' in parameter else \"'\"\n            value_items = [parameter.replace(quote, \"\")]\n            if parameter.count(quote) != 2:\n                while parameters:\n                    parameter = parameters.pop(0)\n                    value_items.append(parameter.replace(quote, \"\"))\n                    if quote in parameter:\n                        break\n            self._save_collected_value(current_field, \" \".join(value_items))\n\n        # handle exact match to model field by name, alias, or serialization_alias\n        elif resolved := self._resolve_field(current_model[\"model\"], parameter):\n            parameter, field = resolved\n            # record presence for previous field before moving on\n            if current_field.get(\n                \"values\"\n            ) is ... and \"presence\" in current_field.get(\"json_schema_extra\", {}):\n                self._save_collected_value(\n                    current_field,\n                    current_field[\"json_schema_extra\"][\"presence\"],\n                )\n            # handle next level model reference\n            if isinstance(field.annotation, ModelMetaclass):\n                current_model = {\n                    \"model\": field.annotation,\n                    \"fields\": [],\n                    \"parameter\": parameter,\n                }\n                models.append(current_model)\n                current_field = {}\n                if len(ret) == 1:\n                    current_model[\"defaults\"] = self.extract_model_defaults(\n                        field.annotation\n                    )\n            # handle dictionary reference\n            elif (\n                get_origin(field.annotation) in (dict, Dict)\n                and field.json_schema_extra\n                and field.json_schema_extra.get(\"pkey\")\n            ):\n                key_name = field.json_schema_extra[\"pkey\"]\n                key_desc = field.json_schema_extra.get(\n                    \"pkey_description\", \"Input key\"\n                )\n\n                # Get value type\n                args = get_args(field.annotation)\n                value_type = args[1] if len(args) &gt; 1 else Any\n\n                current_model = {\n                    \"model\": VirtualDictModel(\n                        key=key_name, description=key_desc, value_type=value_type\n                    ),\n                    \"fields\": [],\n                    \"parameter\": parameter,\n                }\n                models.append(current_model)\n                current_field = {}\n            # handle actual field reference\n            elif isinstance(field, FieldInfo):\n                current_field = {\n                    \"name\": parameter,\n                    \"values\": ...,\n                    \"field\": field,\n                    \"json_schema_extra\": field.json_schema_extra or {},\n                }\n                # find and replace default value if present\n                for idx, f in enumerate(current_model[\"fields\"]):\n                    if f[\"name\"] == current_field[\"name\"]:\n                        current_model[\"fields\"][idx] = current_field\n                        break\n                else:\n                    current_model[\"fields\"].append(current_field)\n            else:\n                raise TypeError(\n                    f\"Unsupported pydantic field type: '{type(field.annotation)}', \"\n                    f\"parameter: '{parameter}', command: '{command}', current model: \"\n                    f\"'{current_model['model']}'\"\n                )\n\n        # check if last field is an Enumerator\n        elif current_field and isinstance(\n            current_field[\"field\"].annotation, enum.EnumMeta\n        ):\n            if any(\n                str(i.value) == parameter for i in current_field[\"field\"].annotation\n            ):\n                self._save_collected_value(current_field, parameter)\n            elif any(\n                str(i.value).startswith(parameter)\n                for i in current_field[\"field\"].annotation\n            ):\n                raise FieldLooseMatchOnly(current_model, parameter)\n\n        # check if parameter partially matches any model field\n        elif self._has_partial_match(current_model[\"model\"], parameter):\n            raise FieldLooseMatchOnly(current_model, parameter)\n\n        # parameter is a value, save it to current field\n        elif current_field:\n            self._save_collected_value(current_field, parameter)\n        else:\n            raise FieldKeyError(current_model, parameter)\n    # check presence for last parameter is not is_help\n    if (\n        is_help is False\n        and current_field.get(\"values\") is ...\n        and \"presence\" in current_field[\"json_schema_extra\"]\n    ):\n        value = current_field[\"json_schema_extra\"][\"presence\"]\n        self._save_collected_value(current_field, value)\n\n    # iterate over collected models and fields to see\n    # if need to collect multi-line input\n    if collect_multiline:\n        for command_models in ret:\n            for model in command_models:\n                for field in model[\"fields\"]:\n                    self._collect_multiline(field)\n\n    return ret\n</code></pre>"},{"location":"api_reference/#picle.App.postloop","title":"<code>picle.App.postloop() -&gt; None</code>","text":"<p>Save readline history to file on shell exit.</p> Source code in <code>picle\\picle.py</code> <pre><code>def postloop(self) -&gt; None:\n    \"\"\"\n    Save readline history to file on shell exit.\n    \"\"\"\n    if HAS_READLINE and self.history_file:\n        try:\n            _readline.write_history_file(os.path.expanduser(self.history_file))\n        except OSError:\n            pass\n</code></pre>"},{"location":"api_reference/#picle.App.print_model_help","title":"<code>picle.App.print_model_help(models: list, verbose: bool = False, match: Optional[str] = None, print_help: bool = True) -&gt; Optional[tuple[list[str], int]]</code>","text":"<p>Form and print help message for model fields.</p> <p>Parameters:</p> <ul> <li> <code>models</code>               (<code>list</code>)           \u2013            <p>List of model dictionaries.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print verbose help.</p> </li> <li> <code>match</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Only collect help for fields that start with this string.</p> </li> <li> <code>print_help</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, prints help; otherwise returns tuple of help lines list and width of longest line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[tuple[list[str], int]]</code>           \u2013            <p>Optional[tuple[list[str], int]]: Help lines and width if print_help is False.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def print_model_help(\n    self,\n    models: list,\n    verbose: bool = False,\n    match: Optional[str] = None,\n    print_help: bool = True,\n) -&gt; Optional[tuple[list[str], int]]:\n    \"\"\"\n    Form and print help message for model fields.\n\n    Args:\n        models (list): List of model dictionaries.\n        verbose (bool): If True, print verbose help.\n        match (str, optional): Only collect help for fields that start with this string.\n        print_help (bool): If True, prints help; otherwise returns tuple of help lines list and width of longest line.\n\n    Returns:\n        Optional[tuple[list[str], int]]: Help lines and width if print_help is False.\n    \"\"\"\n    model = models[-1][-1]  # get last model\n    last_field = model[\"fields\"][-1] if model[\"fields\"] else None\n    fparam = self._get_field_params(last_field)\n    lines = {}  # dict of {cmd: cmd_help}\n    lines_mandatory = {}  # dict of mandatory commands {cmd: cmd_help}\n    width = 0  # record longest command width for padding\n    # print help message only for last collected field\n    if last_field and last_field[\"values\"] == ...:\n        field = last_field[\"field\"]\n        json_schema_extra = last_field[\"json_schema_extra\"]\n        name = f\"&lt;'{last_field['name']}' value&gt;\"\n        # check if field referencing function\n        if json_schema_extra.get(\"function\"):\n            lines[name] = f\"{field.description}\"\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Execute command\"\n        # add options for enumerations\n        elif isinstance(field.annotation, enum.EnumMeta):\n            options = [i.value for i in field.annotation]\n            lines[name] = \", \".join([str(i) for i in options])\n        # check if model has method to source field choices\n        elif hasattr(model[\"model\"], f\"source_{last_field['name']}\"):\n            options = getattr(model[\"model\"], f\"source_{last_field['name']}\")()\n            lines[name] = \", \".join([str(i) for i in options])\n        else:\n            lines[name] = f\"{field.description}\"\n            # check if field supports multiline input\n            if fparam.get(\"multiline\") is True:\n                lines[\"load-terminal\"] = \"Collect value using multi line input mode\"\n            if verbose:\n                lines[name] += (\n                    f\"; default '{field.get_default()}', type '{str(field.annotation)}', \"\n                    f\"is required - {field.is_required()}\"\n                )\n    # collect help message for all fields of this model\n    else:\n        # check if model supports subshell\n        if (\n            hasattr(model[\"model\"], \"PicleConfig\")\n            and getattr(model[\"model\"].PicleConfig, \"subshell\", None) is True\n            # exclude &lt;ENTER&gt; if already in model's shell\n            and not self.shells[-1] == model[\"model\"]\n        ):\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Enter command subshell\"\n        # iterate over model fields\n        for name, field in model_fields(model[\"model\"]).items():\n            # skip fields that already have values\n            if any(f[\"name\"] == name for f in model[\"fields\"]):\n                continue\n            # check if field has alias\n            if field.alias:\n                name = field.alias\n            # check if field has serialization alias\n            if field.serialization_alias:\n                name = field.serialization_alias\n            # filter fields\n            if match and not name.startswith(match):\n                continue\n            # make mandatory fields standing out\n            if field.is_required():\n                lines_mandatory[name] = f\"{field.description}\"\n            else:\n                lines[name] = f\"{field.description}\"\n            if verbose:\n                lines[name] += (\n                    f\"; default '{field.get_default()}', type '{str(field.annotation)}', \"\n                    f\"is required - {field.is_required()}\"\n                )\n\n        # collect VirtualDictModel description\n        if isinstance(model[\"model\"], VirtualDictModel):\n            vdm = model[\"model\"]\n            k = f\"&lt;{vdm.key}&gt;\"\n            if not match or k.startswith(match or \"\"):\n                lines_mandatory[k] = vdm.description or \"\"\n                width = max(width, len(k))\n\n    # check if model has pipe defined\n    if hasattr(model[\"model\"], \"PicleConfig\") and getattr(\n        model[\"model\"].PicleConfig, \"pipe\", None\n    ):\n        name = \"|\"\n        lines[name] = \"Execute pipe command\"\n    width = max((len(k) for k in lines), default=width)\n    # form help lines for mandatory fields first\n    help_msg = []\n    for k in sorted(lines_mandatory.keys()):\n        padding = \" \" * (width - len(k)) + (\" \" * 4)\n        if self.use_rich and HAS_RICH:\n            help_msg.append(f\" [bold]{k}[/bold]{padding}{lines_mandatory[k]}\")\n        else:\n            help_msg.append(f\" \\033[1m{k}\\033[0m{padding}{lines_mandatory[k]}\")\n    # form help lines for non-mandatory fields\n    for k in sorted(lines.keys()):\n        padding = \" \" * (width - len(k)) + (\" \" * 4)\n        help_msg.append(f\" {k}{padding}{lines[k]}\")\n    # make sure ENTER is at the end of help message if subshell supported\n    enter_line = [c for c in help_msg if \"&lt;ENTER&gt;\" in c]\n    if enter_line:\n        help_msg.remove(enter_line[0])\n        help_msg.append(enter_line[0])\n\n    if print_help:  # print help message\n        self.write(self.newline.join(help_msg))\n    else:\n        return help_msg, width\n</code></pre>"},{"location":"api_reference/#picle.App.process_help_command","title":"<code>picle.App.process_help_command(line: str) -&gt; None</code>","text":"<p>Process inline help triggered by '?' or '??' at the end of a command line.</p> <p>Parameters:</p> <ul> <li> <code>line</code>               (<code>str</code>)           \u2013            <p>Input command line string ending with '?' or '??'.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def process_help_command(self, line: str) -&gt; None:\n    \"\"\"\n    Process inline help triggered by '?' or '??' at the end of a command line.\n\n    Args:\n        line (str): Input command line string ending with '?' or '??'.\n    \"\"\"\n    verbose = line.endswith(\"??\")\n    try:\n        command_models = self.parse_command(line.rstrip(\"?\"), is_help=True)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        self.print_model_help([[model]], verbose=verbose, match=parameter)\n    except FieldKeyError as e:\n        model, parameter = e.args\n        self.write_error(\n            f\"Incorrect command, '{parameter}' not part of \"\n            f\"'{self._get_model_name(model)}' model fields\"\n        )\n    else:\n        self.print_model_help(command_models, verbose=verbose)\n</code></pre>"},{"location":"api_reference/#picle.App.write","title":"<code>picle.App.write(output: str) -&gt; None</code>","text":"<p>Write output to stdout.</p> <p>Parameters:</p> <ul> <li> <code>output</code>               (<code>str</code>)           \u2013            <p>Output to write to stdout.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def write(self, output: str) -&gt; None:\n    \"\"\"\n    Write output to stdout.\n\n    Args:\n        output (str): Output to write to stdout.\n    \"\"\"\n    if self.use_rich and HAS_RICH:\n        RICHCONSOLE.print(output)\n    else:\n        if not isinstance(output, str):\n            output = str(output)\n        if not output.endswith(self.newline):\n            output += self.newline\n        self.stdout.write(output)\n    self.stdout.flush()\n</code></pre>"},{"location":"api_reference/#picle.App.write_error","title":"<code>picle.App.write_error(output: str) -&gt; None</code>","text":"<p>Write error output to stdout in red color.</p> <p>Parameters:</p> <ul> <li> <code>output</code>               (<code>str</code>)           \u2013            <p>Error message to write to stdout.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def write_error(self, output: str) -&gt; None:\n    \"\"\"\n    Write error output to stdout in red color.\n\n    Args:\n        output (str): Error message to write to stdout.\n    \"\"\"\n    if self.use_rich and HAS_RICH:\n        self.write(f\"[red]{output}[/red]\")\n    else:\n        self.write(f\"\\033[31m{output}\\033[0m\")\n</code></pre>"},{"location":"api_reference/#picle-build-in-models","title":"PICLE Build In Models","text":""},{"location":"api_reference/#picle.models.Filters","title":"<code>picle.models.Filters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Filters.filter_exclude","title":"<code>picle.models.Filters.filter_exclude(data: Any, exclude: Any = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Filter data line by line using provided pattern. Returns only lines that do not contain the requested exclude pattern.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Data to filter.</p> </li> <li> <code>exclude</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Pattern to filter data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Filtered lines joined by newline.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef filter_exclude(data: Any, exclude: Any = None) -&gt; str:\n    \"\"\"\n    Filter data line by line using provided pattern. Returns only lines that do not contain the requested exclude pattern.\n\n    Args:\n        data: Data to filter.\n        exclude: Pattern to filter data.\n\n    Returns:\n        str: Filtered lines joined by newline.\n    \"\"\"\n    exclude = str(exclude)\n    return \"\\n\".join(\n        [line for line in str(data).splitlines() if exclude not in line]\n    )\n</code></pre>"},{"location":"api_reference/#picle.models.Filters.filter_include","title":"<code>picle.models.Filters.filter_include(data: Any, include: Any = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Filter data line by line using provided pattern. Returns only lines that contain the requested include pattern.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Data to filter.</p> </li> <li> <code>include</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Pattern to filter data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Filtered lines joined by newline.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef filter_include(data: Any, include: Any = None) -&gt; str:\n    \"\"\"\n    Filter data line by line using provided pattern. Returns only lines that contain the requested include pattern.\n\n    Args:\n        data: Data to filter.\n        include: Pattern to filter data.\n\n    Returns:\n        str: Filtered lines joined by newline.\n    \"\"\"\n    include = str(include)\n    return \"\\n\".join([line for line in str(data).splitlines() if include in line])\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters","title":"<code>picle.models.Outputters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Outputters.outputter_json","title":"<code>picle.models.Outputters.outputter_json(data: Union[dict, list, bytes], indent: int = 4) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Pretty print JSON string using Rich library.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict, list, or bytes</code>)           \u2013            <p>Data to print.</p> </li> <li> <code>indent</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Indentation for JSON output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>JSON-formatted string or error message.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_json(data: Union[dict, list, bytes], indent: int = 4) -&gt; Any:\n    \"\"\"\n    Pretty print JSON string using Rich library.\n\n    Args:\n        data (dict, list, or bytes): Data to print.\n        indent (int): Indentation for JSON output.\n\n    Returns:\n        Any: JSON-formatted string or error message.\n    \"\"\"\n    if isinstance(data, bytes):\n        data = data.decode(\"utf-8\")\n\n    if isinstance(data, str):\n        return data\n\n    # data should be a json string\n    try:\n        data = json.dumps(data, indent=indent, sort_keys=True)\n    except Exception as e:\n        print(\n            f\"ERROR: Failed to format data as JSON string:\\n{data}\\n\\nError: '{e}'\"\n        )\n\n    return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_kv","title":"<code>picle.models.Outputters.outputter_kv(data: dict) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Format a dictionary as a key-value output string.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>Dictionary to format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Formatted key-value string.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_kv(data: dict) -&gt; str:\n    \"\"\"\n    Format a dictionary as a key-value output string.\n\n    Args:\n        data (dict): Dictionary to format.\n\n    Returns:\n        str: Formatted key-value string.\n    \"\"\"\n    if isinstance(data, str):\n        return data\n    return \"\\n\".join([f\" {k}: {v}\" for k, v in data.items()])\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_nested","title":"<code>picle.models.Outputters.outputter_nested(data: Union[dict, list], initial_indent: int = 0, with_tables: bool = False, tabulate_kwargs: dict = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Recursively formats and prints nested data structures (dictionaries and lists) in a human-readable format.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict or list</code>)           \u2013            <p>Nested data structure to be formatted and printed.</p> </li> <li> <code>initial_indent</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Initial indentation level.</p> </li> <li> <code>with_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, will format flat lists as Tabulate tables.</p> </li> <li> <code>tabulate_kwargs</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Arguments for tabulate table outputter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Formatted nested string.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_nested(\n    data: Union[dict, list],\n    initial_indent: int = 0,\n    with_tables: bool = False,\n    tabulate_kwargs: dict = None,\n) -&gt; str:\n    \"\"\"\n    Recursively formats and prints nested data structures (dictionaries and lists) in a human-readable format.\n\n    Args:\n        data (dict or list): Nested data structure to be formatted and printed.\n        initial_indent (int): Initial indentation level.\n        with_tables (bool): If True, will format flat lists as Tabulate tables.\n        tabulate_kwargs (dict, optional): Arguments for tabulate table outputter.\n\n    Returns:\n        str: Formatted nested string.\n    \"\"\"\n    tabulate_kwargs = tabulate_kwargs or {\"tablefmt\": \"simple\"}\n\n    def is_dictionary_list(data):\n        for item in data:\n            if not isinstance(item, Mapping):\n                return False\n            for i in item.values():\n                if isinstance(i, (list, tuple, Mapping)):\n                    return False\n        return True\n\n    def ustring(indent, msg, prefix=\"\", suffix=\"\"):\n        indent *= \" \"\n        fmt = \"{0}{1}{2}{3}\"\n        return fmt.format(indent, prefix, msg, suffix)\n\n    def nest(ret, indent, prefix, out):\n        if isinstance(ret, bytes):\n            try:\n                ret = ret.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                ret = str(ret)\n\n        if ret is None or ret is True or ret is False:\n            out.append(ustring(indent, ret, prefix=prefix))\n        elif isinstance(ret, Number):\n            out.append(ustring(indent, repr(ret), prefix=prefix))\n        elif isinstance(ret, str):\n            first_line = True\n            for line in ret.splitlines():\n                line_prefix = \" \" * len(prefix) if not first_line else prefix\n                out.append(ustring(indent, line, prefix=line_prefix))\n                first_line = False\n        elif isinstance(ret, (list, tuple)):\n            # make a text table if it is a flat list\n            if with_tables and is_dictionary_list(ret):\n                table = Outputters.outputter_tabulate_table(ret, **tabulate_kwargs)\n                nest(table, indent + 2, prefix, out)\n            else:\n                for ind in ret:\n                    if isinstance(ind, (list, tuple, Mapping)):\n                        out.append(ustring(indent, \"|_\"))\n                        prefix = \"\" if isinstance(ind, Mapping) else \"- \"\n                        nest(ind, indent + 2, prefix, out)\n                    else:\n                        nest(ind, indent, \"- \", out)\n        elif isinstance(ret, Mapping):\n            if indent:\n                out.append(ustring(indent, \"----------\"))\n\n            for key in ret.keys():\n                val = ret[key]\n                out.append(ustring(indent, key, suffix=\":\", prefix=prefix))\n                nest(val, indent + 4, \"\", out)\n\n        return out\n\n    # make sure data is sorted\n    try:\n        if isinstance(data, dict):\n            data = dict(sorted(data.items()))\n        elif isinstance(data, list):\n            data = list(sorted(data))\n    except Exception as e:\n        log.warning(f\"Nested outputter data sorting failed: '{e}'\")\n\n    lines = nest(data, initial_indent, \"\", [])\n    lines = \"\\n\".join(lines)\n\n    return lines\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_pprint","title":"<code>picle.models.Outputters.outputter_pprint(data: Any) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Pretty-print results using Python's pprint module.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Any data to pretty-print.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Nicely formatted string representation.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_pprint(data: Any) -&gt; str:\n    \"\"\"\n    Pretty-print results using Python's pprint module.\n\n    Args:\n        data: Any data to pretty-print.\n\n    Returns:\n        str: Nicely formatted string representation.\n    \"\"\"\n    if isinstance(data, str):\n        return data\n    return pprint.pformat(data, indent=4)\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_markdown","title":"<code>picle.models.Outputters.outputter_rich_markdown(data: Any) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Print markdown output using Rich library.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Any data to print.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Rich Markdown object or string.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_markdown(data: Any) -&gt; Any:\n    \"\"\"\n    Print markdown output using Rich library.\n\n    Args:\n        data: Any data to print.\n\n    Returns:\n        Any: Rich Markdown object or string.\n    \"\"\"\n    if not isinstance(data, str):\n        data = str(data)\n\n    if HAS_RICH:\n        return Markdown(data)\n    else:\n        return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_table","title":"<code>picle.models.Outputters.outputter_rich_table(data: list[dict], headers: list = None, title: str = None, sortby: str = None) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Format a list of dictionaries as a Rich table.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>list[dict]</code>)           \u2013            <p>List of dictionaries to display.</p> </li> <li> <code>headers</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Column headers; defaults to the keys of the first row.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Table title.</p> </li> <li> <code>sortby</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Key name to sort rows by.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>A Rich Table object, or the original data if Rich is unavailable.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_table(\n    data: list[dict], headers: list = None, title: str = None, sortby: str = None\n) -&gt; Any:\n    \"\"\"\n    Format a list of dictionaries as a Rich table.\n\n    Args:\n        data (list[dict]): List of dictionaries to display.\n        headers (list, optional): Column headers; defaults to the keys of the first row.\n        title (str, optional): Table title.\n        sortby (str, optional): Key name to sort rows by.\n\n    Returns:\n        Any: A Rich Table object, or the original data if Rich is unavailable.\n    \"\"\"\n    if not HAS_RICH or not isinstance(data, list):\n        return data\n\n    if not data:\n        return data\n\n    headers = headers or list(data[0].keys())\n    table = RICHTABLE(title=title, box=False)\n\n    # add table columns\n    for h in headers:\n        table.add_column(h, justify=\"left\", no_wrap=True)\n\n    # sort the table\n    if sortby:\n        sorted_data = sorted(data, key=lambda d: d[sortby])\n    else:\n        sorted_data = data\n\n    # add table rows\n    for item in sorted_data:\n        cells = [str(item.get(h, \"\")) for h in headers]\n        table.add_row(*cells)\n\n    return table\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_save","title":"<code>picle.models.Outputters.outputter_save(data: Any, save: str) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Output data into a file.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Any data to print.</p> </li> <li> <code>save</code>               (<code>str</code>)           \u2013            <p>File path to save data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The data that was saved.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_save(data: Any, save: str) -&gt; Any:\n    \"\"\"\n    Output data into a file.\n\n    Args:\n        data: Any data to print.\n        save (str): File path to save data.\n\n    Returns:\n        Any: The data that was saved.\n    \"\"\"\n    # create directories\n    abspath = os.path.abspath(save)\n    dirs = os.path.split(abspath)[0]\n    os.makedirs(dirs, exist_ok=True)\n\n    # save data to file\n    with open(save, \"w\") as f:\n        if isinstance(data, str):\n            f.write(data)\n        else:\n            f.write(str(data))\n\n    return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_tabulate_table","title":"<code>picle.models.Outputters.outputter_tabulate_table(data: list, headers_exclude: list = None, sortby: str = None, reverse: bool = False, tablefmt: str = 'grid', headers: list = None, showindex: bool = True, maxcolwidths: int = None) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Format and output data as a text table using the tabulate library.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>list</code>)           \u2013            <p>A list of dictionaries or list of lists to be formatted into a table. If it is a list of lists, the function merges nested lists.</p> </li> <li> <code>headers_exclude</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>A list or comma-separated string of headers to exclude from the table.</p> </li> <li> <code>sortby</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key name to sort the table by. If None, no sorting is applied.</p> </li> <li> <code>reverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, reverses the sort order. Defaults to False.</p> </li> <li> <code>tablefmt</code>               (<code>str</code>, default:                   <code>'grid'</code> )           \u2013            <p>Table format style.</p> </li> <li> <code>headers</code>               (<code>list or str</code>, default:                   <code>None</code> )           \u2013            <p>Specifies the table headers. Can be a list, a comma-separated string, or 'keys' to use dictionary keys as headers.</p> </li> <li> <code>showindex</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, includes an index column in the table.</p> </li> <li> <code>maxcolwidths</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Maximum width of the column before wrapping text.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Tabulated table string or error message.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_tabulate_table(\n    data: list,\n    headers_exclude: list = None,\n    sortby: str = None,\n    reverse: bool = False,\n    tablefmt: str = \"grid\",\n    headers: list = None,\n    showindex: bool = True,\n    maxcolwidths: int = None,\n) -&gt; Any:\n    \"\"\"\n    Format and output data as a text table using the tabulate library.\n\n    Args:\n        data (list): A list of dictionaries or list of lists to be formatted into a table. If it is a list of lists, the function merges nested lists.\n        headers_exclude (list, optional): A list or comma-separated string of headers to exclude from the table.\n        sortby (str, optional): The key name to sort the table by. If None, no sorting is applied.\n        reverse (bool, optional): If True, reverses the sort order. Defaults to False.\n        tablefmt (str): Table format style.\n        headers (list or str, optional): Specifies the table headers. Can be a list, a comma-separated string, or 'keys' to use dictionary keys as headers.\n        showindex (bool, optional): If True, includes an index column in the table.\n        maxcolwidths (int, optional): Maximum width of the column before wrapping text.\n\n    Returns:\n        Any: Tabulated table string or error message.\n    \"\"\"\n    if not HAS_TABULATE:\n        log.error(\n            \"PICLE Table outputter tabulate library import failed, install: pip install tabulate\"\n        )\n        return data\n    if not isinstance(data, list):\n        log.error(\"PICLE Table outputter data is not a list\")\n        return data\n\n    # transform headers to exclude argument\n    headers_exclude = headers_exclude or []\n    if isinstance(headers_exclude, str) and \",\" in headers_exclude:\n        headers_exclude = [i.strip() for i in headers_exclude.split(\",\")]\n\n    # form base tabulate arguments\n    if isinstance(headers, str):\n        headers = [i.strip() for i in headers.split(\",\")]\n    elif headers is None:\n        headers = \"keys\"\n\n    tabulate_kw = {\n        \"headers\": headers,\n        \"tablefmt\": tablefmt,\n        \"maxcolwidths\": maxcolwidths,\n    }\n\n    # form singe table out of list of lists\n    table_ = []\n    while data:\n        item = data.pop(0)\n        if isinstance(item, list):\n            table_.extend(item)\n        else:\n            table_.append(item)\n    data = table_\n\n    # sort results\n    if sortby:\n        data = sorted(\n            data,\n            reverse=reverse,\n            key=lambda item: str(item.get(sortby, \"\")),\n        )\n\n    # filter table headers if requested to do so\n    if headers_exclude:\n        data = [\n            {k: v for k, v in res.items() if k not in headers_exclude}\n            for res in data\n        ]\n\n    # transform data content to match headers\n    if isinstance(tabulate_kw[\"headers\"], list):\n        data = [[item.get(i, \"\") for i in tabulate_kw[\"headers\"]] for item in data]\n\n    # start index with 1 instead of 0\n    if showindex is True:\n        showindex = range(1, len(data) + 1)\n        tabulate_kw[\"showindex\"] = showindex\n\n    return tabulate_lib.tabulate(data, **tabulate_kw)\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_yaml","title":"<code>picle.models.Outputters.outputter_yaml(data: Union[dict, list, bytes], absolute_indent: int = 0, indent: int = 2) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Format structured data as a YAML string.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict, list, or bytes</code>)           \u2013            <p>Data to print.</p> </li> <li> <code>absolute_indent</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Indentation to prepend for entire output.</p> </li> <li> <code>indent</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Indentation for YAML output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>YAML-formatted string or error message.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_yaml(\n    data: Union[dict, list, bytes], absolute_indent: int = 0, indent: int = 2\n) -&gt; Any:\n    \"\"\"\n    Format structured data as a YAML string.\n\n    Args:\n        data (dict, list, or bytes): Data to print.\n        absolute_indent (int): Indentation to prepend for entire output.\n        indent (int): Indentation for YAML output.\n\n    Returns:\n        Any: YAML-formatted string or error message.\n    \"\"\"\n    if isinstance(data, bytes):\n        data = data.decode(\"utf-8\")\n\n    if isinstance(data, str):\n        return data\n\n    # data should be a YAML string\n    try:\n        if HAS_YAML:\n            data = yaml.safe_dump(\n                data, default_flow_style=False, sort_keys=True, indent=indent\n            )\n            # add  indent\n            if absolute_indent:\n                data = \"\\n\".join(\n                    [f\"{' ' * absolute_indent}{i}\" for i in data.splitlines()]\n                )\n        else:\n            log.error(\n                \"PICLE YAML outputter yaml library import failed, install: pip install pyyaml\"\n            )\n    except Exception as e:\n        print(\n            f\"ERROR: Failed to format data as YAML string:\\n{data}\\n\\nError: '{e}'\"\n        )\n\n    return data\n</code></pre>"},{"location":"api_reference/#picle.models.PipeFunctionsModel","title":"<code>picle.models.PipeFunctionsModel</code>","text":"<p>               Bases: <code>Filters</code>, <code>Outputters</code></p> <p>Collection of common pipe functions to use in PICLE shell models</p>"},{"location":"api_reference/#picle.models.MAN","title":"<code>picle.models.MAN</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Manual and documentation related functions</p>"},{"location":"api_reference/#picle.models.MAN.print_model_json_schema","title":"<code>picle.models.MAN.print_model_json_schema(root_model: object, **kwargs: dict) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Print model JSON schema for shell model specified by dot separated path (e.g. model.shell.command).</p> <p>Parameters:</p> <ul> <li> <code>root_model</code>               (<code>object</code>)           \u2013            <p>PICLE App root model to print JSON schema for.</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments (expects 'json_schema' for path).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON schema as a formatted string.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef print_model_json_schema(root_model: object, **kwargs: dict) -&gt; str:\n    \"\"\"\n    Print model JSON schema for shell model specified by dot separated path (e.g. model.shell.command).\n\n    Args:\n        root_model: PICLE App root model to print JSON schema for.\n        **kwargs: Additional keyword arguments (expects 'json_schema' for path).\n\n    Returns:\n        str: JSON schema as a formatted string.\n    \"\"\"\n\n    class MyGenerateJsonSchema(GenerateJsonSchema):\n        def handle_invalid_for_json_schema(\n            self, schema: core_schema.CoreSchema, error_info: str\n        ) -&gt; JsonSchemaValue:\n            raise PydanticOmit\n\n        def callable_schema(self, schema):\n            print(schema)\n            raise PydanticOmit\n\n        def render_warning_message(kind, detail: str) -&gt; None:\n            print(kind, detail)\n\n    path = kwargs[\"json_schema\"].split(\".\") if kwargs.get(\"json_schema\") else []\n    model = MAN._recurse_to_model(root_model, path=path)\n    return json.dumps(\n        model.model_json_schema(schema_generator=MyGenerateJsonSchema),\n        indent=4,\n        sort_keys=True,\n    )\n</code></pre>"},{"location":"api_reference/#picle.models.MAN.print_model_tree","title":"<code>picle.models.MAN.print_model_tree(root_model: object, **kwargs: dict) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Print model tree for shell model specified by dot separated path (e.g. model.shell.command).</p> <p>Parameters:</p> <ul> <li> <code>root_model</code>               (<code>object</code>)           \u2013            <p>PICLE App root model to print tree for.</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments (expects 'tree' for path).</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef print_model_tree(root_model: object, **kwargs: dict) -&gt; None:\n    \"\"\"\n    Print model tree for shell model specified by dot separated path (e.g. model.shell.command).\n\n    Args:\n        root_model: PICLE App root model to print tree for.\n        **kwargs: Additional keyword arguments (expects 'tree' for path).\n    \"\"\"\n    if HAS_RICH:\n        RICHCONSOLE.print(\n            \"\\n[bold]R[/bold] - required field, \"\n            + \"[bold]M[/bold] - supports multiline input, \"\n            + \"[bold]D[/bold] - dynamic key\\n\"\n        )\n        path = kwargs[\"tree\"].split(\".\") if kwargs.get(\"tree\") else []\n        rich_tree = RICHTREE(\"[bold]root[/bold]\")\n        RICHCONSOLE.print(\n            MAN._construct_model_tree(\n                model=root_model.model_construct(), tree=rich_tree, path=path\n            )\n        )\n    else:\n        log.error(\n            \"PICLE model tree outputter requires Rich library, install: pip install rich\"\n        )\n</code></pre>"},{"location":"changelog/","title":"0.11.0","text":""},{"location":"changelog/#features","title":"FEATURES","text":"<ol> <li>Adding commands history persistency across shells, added <code>picle_file</code> config attribute to indicate where to store commands, default is <code>picle_history.txt</code></li> <li>Support added to handle parsing of cli commands into dynamic dictionaries, added <code>pkey</code> and <code>pkey_description</code> config parameters to <code>json_schema_extra</code></li> </ol>"},{"location":"changelog/#changes","title":"CHANGES","text":"<ol> <li>Enhanced MAN model to output tree for dynamic dictionaries models</li> <li>Changing history handling to use <code>pyreadline</code> module</li> </ol>"},{"location":"changelog/#0101","title":"0.10.1","text":""},{"location":"changelog/#bugs","title":"BUGS","text":"<ol> <li>MAN fixing examples output when examples are anything but string</li> </ol>"},{"location":"changelog/#changes_1","title":"CHANGES","text":"<ol> <li>Making mandatory fields to be at the top of help output and in bold cursor</li> <li>To invoke multiline input mode changing command from <code>input</code> to <code>load-terminal</code></li> </ol>"},{"location":"changelog/#features_1","title":"FEATURES","text":"<ol> <li>Adding <code>history</code> command to output commands history, adding <code>history_length</code> PicleConfig class config attribute</li> <li>Improving message back to a user for incorrect command with suggesting possible completions</li> <li>Enhancing errors output printed to the screen by making it to be printed in red color</li> </ol>"},{"location":"changelog/#0100","title":"0.10.0","text":""},{"location":"changelog/#changes_2","title":"CHANGES","text":"<ol> <li>Dependencies updates to loosen them up</li> <li>Adding type hints throughout and updating doc strings</li> <li>Fixed pydantic warnings about model_fields access and about using extra arguments on fields</li> </ol>"},{"location":"changelog/#features_2","title":"FEATURES","text":"<ol> <li>Added ConfigModel model to picle to help with maintaininng configuration files using Picle interactive shell.</li> </ol>"},{"location":"changelog/#bugs_1","title":"BUGS","text":"<ol> <li>init ~L97 -PicleConfig accessed without hasattr guard \u2014 crash for models without it</li> <li>do_help ~L855 - Multi-word help silently discarded \u2014 never printed</li> <li>do_help ~L857 - Unhandled FieldLooseMatchOnly/FieldKeyError exceptions</li> <li>print_model_help - Medium    width not computed for all lines keys \u2014 misaligned output</li> <li>default ~L1004 - Partial alias match reports empty completions list</li> <li>do_exit ~L872 - Missing PicleConfig guard on prompt access</li> <li>do_top ~L883 - Same missing guard</li> </ol>"},{"location":"changelog/#093","title":"0.9.3","text":""},{"location":"changelog/#changes_3","title":"CHANGES","text":"<ol> <li>Improving outputter models handling</li> </ol>"},{"location":"changelog/#092","title":"0.9.2","text":""},{"location":"changelog/#changes_4","title":"CHANGES","text":"<ol> <li>Improved value conversion logic to not convert values to integers or bool etc if field annotation is <code>str</code> or <code>StrictStr</code></li> <li>Updated <code>pyproject.toml</code> file with dependency version for PyYAML and Tabulate modules</li> </ol>"},{"location":"changelog/#091","title":"0.9.1","text":""},{"location":"changelog/#features_3","title":"FEATURES","text":"<ol> <li>Extending nested outputter with capability to include tables within nested output if data is a list of dictionaries</li> </ol>"},{"location":"changelog/#090","title":"0.9.0","text":""},{"location":"changelog/#changes_5","title":"CHANGES","text":"<ol> <li>Removed support for using <code>Callable</code> annotation for calling model method</li> <li>Removed formatters from built in models, instead need to use outputter</li> <li>Improved pipe functions handling logic </li> <li>Rich is now a default outputter, can be disabled using <code>use_rich</code> config parameter in the root's model PicleConfig </li> </ol>"},{"location":"changelog/#features_4","title":"FEATURES","text":"<ol> <li>Added Tabulate table outputter</li> <li>Added <code>save</code> outputter to save results into a file</li> <li>Added support for pipe attribute to reference <code>path.to.pipemodel</code> Python import string</li> </ol>"},{"location":"features/configuration_model/","title":"<code>ConfigModel</code> (configuration shells)","text":"<p>PICLE ships a helper base model for \u201cconfiguration-mode\u201d shells: <code>picle.models.ConfigModel</code>. It implements a common workflow:</p> <ul> <li>Load configuration from YAML (optional dependency: <code>pyyaml</code>)</li> <li>Stage edits into a temporary file (<code>&lt;config_file&gt;.tmp</code>)</li> <li>Review staged changes (<code>show changes</code>) and commit them (<code>commit</code>)</li> <li>Keep rotating backups on commit (<code>.old1</code>, <code>.old2</code>, ...)</li> <li>Roll back by loading a backup into the temp file (<code>rollback &lt;n&gt;</code>) and then committing</li> </ul>"},{"location":"features/configuration_model/#configmodelpicleconfig-keys","title":"<code>ConfigModel.PicleConfig</code> keys","text":"<p><code>ConfigModel</code> reads additional settings from the concrete model\u2019s <code>PicleConfig</code>. These keys are only honored by <code>ConfigModel</code> (the core <code>App</code> ignores them):</p> Name Meaning <code>config_file</code> Path to the YAML config file (default: <code>configuration.yaml</code>) <code>backup_on_save</code> How many <code>.oldN</code> backups to keep when committing (0 disables backups) <code>commit_hook</code> Optional callable invoked after a successful commit"},{"location":"features/configuration_model/#sample-config-model-shell","title":"Sample Config Model Shell","text":"<p>Below is example of how to use configuration model to construct interactive shell to manage YAML file content.</p> <pre><code>\"\"\"\nExample demonstrating ConfigModel usage in PICLE shells.\n\nThis example shows how to create a configuration management system using\nConfigModel to handle YAML configuration files with structured validation.\n\"\"\"\n\nfrom enum import Enum\nfrom typing import Optional, Dict\nfrom pydantic import BaseModel, Field, ConfigDict, StrictStr\n\nfrom picle.models import ConfigModel, PipeFunctionsModel\nfrom picle.picle import App\n\n# --------------------------------------------------------------------------------\n# Configuration Structure Models\n# --------------------------------------------------------------------------------\n\n\nclass SeverityEnum(str, Enum):\n    \"\"\"Logging severity levels.\"\"\"\n\n    debug = \"debug\"\n    info = \"info\"\n    warning = \"warning\"\n    error = \"error\"\n    critical = \"critical\"\n\n\nclass TerminalLoggingConfig(BaseModel):\n    \"\"\"Terminal logging configuration.\"\"\"\n\n    severity: SeverityEnum = Field(\n        SeverityEnum.info, description=\"Logging severity level\"\n    )\n    format: str = Field(None, description=\"Log message format\", alias=\"format\")\n\n\nclass FileLoggingConfig(BaseModel):\n    \"\"\"File logging configuration.\"\"\"\n\n    enabled: bool = Field(False, description=\"Enable file logging\")\n    path: str = Field(None, description=\"Log file path\")\n    severity: SeverityEnum = Field(\n        SeverityEnum.warning, description=\"File logging severity level\"\n    )\n\n\nclass LoggingConfigModel(BaseModel):\n    \"\"\"Main logging configuration.\"\"\"\n\n    terminal: TerminalLoggingConfig = Field(\n        None, description=\"Terminal logging configuration\"\n    )\n    file: FileLoggingConfig = Field(None, description=\"File logging configuration\")\n\nclass WorkerConfigModel(BaseModel):\n    timeout: int = Field(None, description=\"Worker timeout in seconds\")\n    num_threads: int = Field(None, description=\"Number of worker threads\")\n    use_chache: bool = Field(None, description=\"Whether to use cache for worker results\")\n\n\n# --------------------------------------------------------------------------------\n# Configuration Store with Commands\n# --------------------------------------------------------------------------------\n\n\nclass MyConfigStore(ConfigModel):\n    \"\"\"\n    Configuration store for application settings.\n\n    This model manages YAML configuration files and provides commands\n    to view, get, and set configuration values.\n    \"\"\"\n\n    # Configuration structure definition\n    logging: LoggingConfigModel = Field(None, description=\"Logging configuration\")\n    workers: dict[StrictStr, WorkerConfigModel] = Field(\n        None, description=\"Worker configurations\", json_schema_extra={\"pkey\": \"worker_name\", \"pkey_description\": \"Name of the worker\"}\n    )\n    class PicleConfig:\n        subshell = True\n        prompt = \"test-config-shell[cfg]#\"\n        config_file = \"app_config.yaml\"  # Default config file path\n\n\n# --------------------------------------------------------------------------------\n# Root Shell Model\n# --------------------------------------------------------------------------------\n\n\nclass RootShell(BaseModel):\n    \"\"\"Root shell with config command.\"\"\"\n\n    configure_terminal: MyConfigStore = Field(\n        None, description=\"Configuration management commands\"\n    )\n\n    class PicleConfig:\n        pipe = PipeFunctionsModel\n        prompt = \"test-config-shell#\"\n\n\n# --------------------------------------------------------------------------------\n# Example Usage\n# --------------------------------------------------------------------------------\n\n\nif __name__ == \"__main__\":\n    shell = App(RootShell)\n    shell.start()\n</code></pre> <p>Above app constructs shell with this commands tree:</p> <pre><code>test-config-shell#man tree configure_terminal\n\nR - required field, M - supports multiline input, D - dynamic key\n\nroot\n\u2514\u2500\u2500 configure_terminal:    Configuration management commands\n    \u251c\u2500\u2500 show:    Show commands\n    \u2502   \u251c\u2500\u2500 configuration:    Show running configuration content\n    \u2502   \u2514\u2500\u2500 changes:    Show uncommitted changes diff between temp and running config\n    \u251c\u2500\u2500 commit:    Commit pending config changes\n    \u251c\u2500\u2500 rollback:    Rollback to a backup version\n    \u251c\u2500\u2500 erase-configuration:    Erase running configuration\n    \u251c\u2500\u2500 clear-changes:    Discard uncommitted changes\n    \u251c\u2500\u2500 logging:    Logging configuration\n    \u2502   \u251c\u2500\u2500 terminal:    Terminal logging configuration\n    \u2502   \u2502   \u251c\u2500\u2500 severity:    Logging severity level, default 'SeverityEnum.info'\n    \u2502   \u2502   \u2514\u2500\u2500 format:    Log message format\n    \u2502   \u2514\u2500\u2500 file:    File logging configuration\n    \u2502       \u251c\u2500\u2500 enabled:    Enable file logging, default 'False'\n    \u2502       \u251c\u2500\u2500 path:    Log file path\n    \u2502       \u2514\u2500\u2500 severity:    File logging severity level, default 'SeverityEnum.warning'\n    \u2514\u2500\u2500 workers:    Worker configurations\n        \u251c\u2500\u2500 worker_name (D):    Name of the worker\n        \u251c\u2500\u2500 timeout:    Worker timeout in seconds\n        \u251c\u2500\u2500 num_threads:    Number of worker threads\n        \u2514\u2500\u2500 use_cache:    Whether to use cache for worker results\ntest-config-shell#\n</code></pre> <p>And above shell can be used like this:</p> <pre><code>test-config-shell#configure_terminal\ntest-config-shell[cfg]#workers ?\n &lt;worker_name&gt;    Name of the worker\ntest-config-shell[cfg]#workers worker-1 ?\n num_threads    Number of worker threads\n timeout        Worker timeout in seconds\n use_cache      Whether to use cache for worker results\ntest-config-shell[cfg]#workers worker-1 num_threads 1 timeout 1 use_cache True\nConfiguration updated (uncommitted). Use 'commit' to save or 'show changes' to review.\ntest-config-shell[cfg]#show changes\n--- app_config.yaml\n+++ app_config.yaml.tmp\n@@ -1 +1,6 @@\n-{}\n+workers:\n+  worker-1:\n+    num_threads: 1\n+    timeout: 1\n+    use_cache: true\n+    worker_name: worker-1\ntest-config-shell[cfg]#commit\nConfiguration committed successfully\ntest-config-shell[cfg]#exit\ntest-config-shell#\n</code></pre>"},{"location":"features/dynamic_dictionary_input/","title":"Dynamic Dictionary Input","text":""},{"location":"features/dynamic_dictionary_input/#problem","title":"Problem","text":"<p>Pydantic models does not support free-form dictionary keys.</p> <p>The solution works by creating a temporary, invisible \"bridge\" when PICLE encounters a Python Dictionary field <code>(Dict[...])</code>.</p> <p>Here is the simple breakdown.</p>"},{"location":"features/dynamic_dictionary_input/#1-the-bridge-virtualdictmodel","title":"1. The \"Bridge\" (VirtualDictModel)","text":"<p>Normally, PICLE looks for exact matches of field names in your Pydantic model. However, a dictionary implies that you get to invent the key name (like name1 or my_entry) at runtime. PICLE cannot know this name in advance.</p> <p>When PICLE sees a field like <code>mytopkey: Dict[str, MyNestedModel]</code>, it creates a special <code>VirtualDictModel</code>. Think of this as a placeholder that says: \"I am waiting for one word to serve as the dictionary key.\"</p>"},{"location":"features/dynamic_dictionary_input/#2-how-it-flows-step-by-step","title":"2. How it flows step-by-step","text":"<p>When you type the command: picle# mytopkey name1 k1 v1</p> <p>mytopkey: PICLE finds this field in your root model. It sees it is a Dict. It switches to the \"Bridge\" mode. name1: PICLE expects a key here. It grabs \"name1\" and says, \"Okay, this is the key for our dictionary.\" Transition: PICLE looks at the dictionary definition (Dict[..., MyNestedModel]). It knows that whatever is under this key must look like MyNestedModel.</p> <p>k1 v1: PICLE now switches to MyNestedModel and parses k1 v1 just like normal fields.</p>"},{"location":"features/dynamic_dictionary_input/#3-reconstructing-the-data","title":"3. Reconstructing the Data","text":"<p>At the end, PICLE takes these three pieces\u2014the field name (mytopkey), the captured key (name1), and the nested data ({'k1': 'v1'})\u2014and stitches them together into the final nested structure:</p>"},{"location":"features/dynamic_dictionary_input/#4-customizing-help","title":"4. Customizing Help","text":"<p>To make the \"Bridge\" user-friendly, we look at json_schema_extra keys (pkey and pkey_description).</p> <p>Instead of showing nothing, PICLE uses these to tell the user:  Input name when they ask for help (?). This allows you to mix structured, strict Pydantic models with free-form dictionary keys seamlessly."},{"location":"features/fields_presence/","title":"Fields Presence","text":"<p><code>presence</code> is useful for boolean-ish flags where you want the value to be set just by mentioning the field.</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Root(BaseModel):\n    verbose: bool = Field(\n        False,\n        description=\"Enable verbose mode\",\n        json_schema_extra={\"presence\": True},\n    )\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n</code></pre> <p>Example interaction:</p> <pre><code>picle#verbose\n{'verbose': True}\n</code></pre>"},{"location":"features/mounting_models_at_runtime/","title":"Mounting/removing models at runtime","text":"<p><code>App</code> can add/remove models to the root tree:</p> <pre><code>from pydantic import BaseModel, Field, StrictStr\nfrom picle import App\n\n\nclass Mounted(BaseModel):\n    param: StrictStr = Field(None, description=\"Param string\")\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n\n\nclass Root(BaseModel):\n    command: StrictStr = Field(None, description=\"Some command\")\n\n\nshell = App(Root)\nshell.model_mount(Mounted, [\"another_command\"])\nshell.model_remove([\"another_command\"])\n</code></pre> <p>Notes:</p> <ul> <li><code>path</code> may be a list of segments or a single string.</li> <li><code>model_mount</code> can only mount under an existing path, except for the final segment (which is created).</li> <li>Mounted fields are added to the root model\u2019s <code>model_fields</code> and participate in completion/help.</li> </ul>"},{"location":"features/multiline_input/","title":"Multi-line input","text":"<p>If a field enables multi-line input, the user can type the literal value <code>input</code> to start collection. PICLE reads lines until EOF (Ctrl+D) and uses the collected text (joined by <code>\\n</code>) as the field value.</p> <pre><code>from typing import Any\nfrom pydantic import BaseModel, Field, StrictStr\n\n\nclass TestMultilineInput(BaseModel):\n    data: StrictStr = Field(\n        None,\n        description=\"Multi line string\",\n        json_schema_extra={\"multiline\": True},\n    )\n    arg: Any = Field(None, description=\"Some field\")\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n\n\nclass Root(BaseModel):\n    test_multiline_input: TestMultilineInput = Field(\n        None,\n        description=\"Multi-line input demo\",\n    )\n</code></pre> <p>Help shows the <code>input</code> option when appropriate:</p> <pre><code>picle#test_multiline_input data ?\n &lt;'data' value&gt;    Multi line string\n input             Collect value using multi line input mode\n</code></pre> <p>Invoking multi-line collection:</p> <pre><code>picle#test_multiline_input data input arg foo\nEnter lines and hit Ctrl+D to finish multi line input\nline 1\nline 2\n&lt;Ctrl+D&gt;\n</code></pre>"},{"location":"features/pipes/","title":"Pipes","text":"<p>If PicleConfig class <code>pipe</code> is set, the <code>|</code> token becomes valid and starts a new \u201csegment\u201d. The next segment is parsed using the pipe model. <code>pipe</code> can be:</p> <pre><code>\"self\"                  re-use the current model as the pipe model\n\"some.module.Model\"     import a model by string\nSomeModelClass          use a model class directly\n</code></pre> <p>Example (enable pipe functions and post-process the first command):</p> <pre><code>from pydantic import BaseModel\nfrom picle.models import PipeFunctionsModel, Outputters\n\n\nclass ShellModel(BaseModel):\n    class PicleConfig:\n        prompt = \"picle#\"\n        intro = \"PICLE Sample app\"\n        pipe = PipeFunctionsModel\n        processors = [Outputters.outputter_json]\n</code></pre> <p>!!! note <code>processors</code> run on the first command segment only (before any <code>|</code> segments). They do not apply to subsequent pipe segments. If you want to post-process the output of a pipe segment, use an outputter or a pipe function in that segment.</p>"},{"location":"features/processors/","title":"Processors","text":"<p>Processors are just functions that transform results. They run in order.</p> <pre><code>from typing import Any\nfrom pydantic import BaseModel, Field\nfrom picle.models import Outputters\n\n\nclass ModelShow(BaseModel):\n    data_pprint: Any = Field(\n        None,\n        description=\"Show structured data using pprint\",\n        json_schema_extra={\n            \"function\": \"produce_structured_data\",\n            \"processors\": [Outputters.outputter_pprint],\n        },\n    )\n\n    @staticmethod\n    def produce_structured_data():\n        return {\"some\": {\"nested\": {\"data\": None}}}\n</code></pre> <p>If you also set <code>PicleConfig.processors</code>, they run for the first segment after field-level processors.</p>"},{"location":"features/result_specific_outputters/","title":"Result-specific Outputters","text":"<p>Sometimes a single model-level outputter is not enough. If you need to choose an outputter based on runtime data, return a tuple from <code>run()</code>:</p> <pre><code>(result, outputter)\n(result, outputter, outputter_kwargs)\n</code></pre> <p>This overrides model and field outputters for that specific execution.</p>"}]}
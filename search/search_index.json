{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PICLE","text":"<p>PICLE builds interactive command-line shells from Pydantic v2 models. It uses Python\u2019s standard <code>cmd</code> loop under the hood and turns each entered line into a walk through a model tree:</p> <pre><code>Root model\n  \u251c\u2500 field -&gt; sub-model (becomes a command group)\n  \u251c\u2500 field -&gt; value (collects validated input)\n  \u2514\u2500 field -&gt; function (execute when ENTER is pressed)\n</code></pre> <p>What you get out of the box:</p> <ul> <li>Nested commands (models inside models)</li> <li>Validation and type conversion via Pydantic</li> <li>Inline discovery with <code>?</code> / <code>??</code> and tab completion</li> <li>Optional piping with <code>|</code> to post-process results</li> <li>Optional Rich/Tabulate/YAML output helpers (extras)</li> </ul> <p>Install:</p> <pre><code>pip install picle\n</code></pre> <p>A minimal example:</p> <pre><code>import time\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field\nfrom picle import App\n\n\nclass Show(BaseModel):\n    version: Any = Field(\n        None,\n        description=\"Show software version\",\n        json_schema_extra={\"function\": \"show_version\"},\n    )\n    clock: Any = Field(\n        None,\n        description=\"Show current clock\",\n        json_schema_extra={\"function\": \"show_clock\"},\n    )\n\n    @staticmethod\n    def show_version():\n        return \"0.1.0\"\n\n    @staticmethod\n    def show_clock():\n        return time.ctime()\n\n\nclass Root(BaseModel):\n    show: Show = Field(None, description=\"Show commands\")\n\n    class PicleConfig:\n        intro = \"PICLE sample app\"\n        prompt = \"picle#\"\n\n\nif __name__ == \"__main__\":\n    App(Root).start()\n</code></pre>"},{"location":"Getting%20Started/","title":"Getting Started","text":""},{"location":"Getting%20Started/#introducing-picle","title":"Introducing PICLE","text":"<p>Command-line interfaces are great when you want a fast workflow: type a command, get output, repeat. In practice, a good interactive shell also needs help, completion, and input validation.</p> <p>PICLE provides those features by turning Pydantic v2 models into an interactive shell. You define a model tree, and PICLE interprets the command line as a walk through that tree.</p> <p>At a high level, your shell looks like this:</p> <pre><code>Root\n  \u251c\u2500 command -&gt; SubModel\n  \u2502    \u251c\u2500 arg -&gt; Field (collect value)\n  \u2502    \u251c\u2500 flag -&gt; Field (presence)\n  \u2502    \u2514\u2500 &lt;ENTER&gt; -&gt; run() / field function\n  \u2514\u2500 command -&gt; Field (collect value)\n</code></pre> <p>Concretely: field names (or <code>alias</code> / <code>serialization_alias</code>) become command tokens. Tokens after a leaf field become that field\u2019s value(s). Once PICLE has enough information,  it validates the collected data with Pydantic and then executes your code.</p> <p>How a line is processed:</p> <pre><code>user input\n  -&gt; parse tokens into (models + fields)\n  -&gt; collect values (supports quotes, JSON-ish {..} / [..], multiline)\n  -&gt; validate with Pydantic\n  -&gt; execute (model.run or field function)\n  -&gt; processors / outputter\n  -&gt; print\n</code></pre>"},{"location":"Getting%20Started/#a-small-shell","title":"A small shell","text":"<p>This creates:</p> <pre><code>Root\n  \u2514\u2500 show\n    \u251c\u2500 version   (function)\n    \u2514\u2500 clock     (function)\n</code></pre> <pre><code>import time\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field\nfrom picle import App\n\n\nclass Show(BaseModel):\n  version: Any = Field(\n    None,\n    description=\"Show software version\",\n    json_schema_extra={\"function\": \"show_version\"},\n  )\n  clock: Any = Field(\n    None,\n    description=\"Show current clock\",\n    json_schema_extra={\"function\": \"show_clock\"},\n  )\n\n  @staticmethod\n  def show_version():\n    return \"0.1.0\"\n\n  @staticmethod\n  def show_clock():\n    return time.ctime()\n\n\nclass Root(BaseModel):\n  show: Show = Field(None, description=\"Show commands\")\n\n  class PicleConfig:\n    prompt = \"picle#\"\n    intro = \"PICLE Sample app\"\n\n\nif __name__ == \"__main__\":\n  App(Root).start()\n</code></pre> <p>Try it:</p> <pre><code>picle#show version\n0.1.0\npicle#show clock\nFri May  2 22:44:01 2025\n</code></pre>"},{"location":"Getting%20Started/#what-gets-executed","title":"What gets executed","text":"<p>PICLE decides what to call in this order:</p> <p>1) If the current model has a <code>run(**kwargs)</code> method, it calls <code>run</code>. 2) Otherwise, if the last referenced field has <code>json_schema_extra={\"function\": \"...\"}</code>, PICLE calls that model staticmethod.</p> <p>That keeps simple \u201ccommand -&gt; function\u201d shells small, while still supporting bigger models that centralize behavior in <code>run()</code>.</p>"},{"location":"Getting%20Started/#help-and-discovery","title":"Help and discovery","text":"<p>PICLE\u2019s help is model-driven:</p> <pre><code>picle#?\n... shows available top-level commands and built-in commands\n\npicle#show ?\n... shows available fields under \"show\"\n\npicle#show version ?\n... shows what ENTER will do\n</code></pre> <p>For a command tree view:</p> <pre><code>picle#man tree\n</code></pre> <p>For a JSON schema (useful if you want to expose your shell as documented data):</p> <pre><code>picle#man json-schema\n</code></pre>"},{"location":"Getting%20Started/#subshells-optional","title":"Subshells (optional)","text":"<p>If a model sets <code>PicleConfig.subshell = True</code>, you can \u201center\u201d that model as a subshell. When you navigate to the model without providing arguments, PICLE pushes it onto a shell stack and updates the prompt.</p> <p>Shell navigation commands:</p> <pre><code>exit   leave current subshell\ntop    return to the root shell\nend    exit the app\npwd    print current shell path\ncls    clear the screen\n</code></pre>"},{"location":"Getting%20Started/#pipes-optional","title":"Pipes (optional)","text":"<p>If the current model declares <code>PicleConfig.pipe</code>, the <code>|</code> token starts a new command segment. The second segment receives the previous segment\u2019s result as its first argument.</p> <pre><code>segment 0 (produce data)\n  | segment 1 (transform/format)\n  | segment 2 (transform/format)\n</code></pre> <p>PICLE includes a ready-to-use pipe model (<code>PipeFunctionsModel</code>) with filters and outputters.</p>"},{"location":"Getting%20Started/#configuration-shells-with-configmodel","title":"Configuration shells with <code>ConfigModel</code>","text":"<p>If you want a CLI that edits a structured YAML configuration, PICLE includes <code>picle.models.ConfigModel</code>. It lets users navigate a nested Pydantic model, stage edits into <code>&lt;config_file&gt;.tmp</code>, review diffs, and then commit.</p> <p>Minimal shape:</p> <pre><code>from pydantic import BaseModel, Field\nfrom picle import App\nfrom picle.models import ConfigModel, PipeFunctionsModel\n\n\nclass Logging(BaseModel):\n  severity: str = Field(None, description=\"Log severity\")\n\n\nclass MyConfig(ConfigModel):\n  logging: Logging = Field(None, description=\"Logging config\")\n\n  class PicleConfig:\n    subshell = True\n    prompt = \"app[cfg]#\"\n    config_file = \"app_config.yaml\"\n\n\nclass Root(BaseModel):\n  configure: MyConfig = Field(None, description=\"Edit configuration\")\n\n  class PicleConfig:\n    prompt = \"app#\"\n    pipe = PipeFunctionsModel\n\n\nif __name__ == \"__main__\":\n  App(Root).start()\n</code></pre> <p>Example interaction:</p> <pre><code>app#configure\napp[cfg]#logging severity debug\nConfiguration updated (uncommitted). Use 'commit' to save or 'show changes' to review.\n\napp[cfg]#show changes\n... unified diff ...\n\napp[cfg]#commit\nConfiguration committed successfully\n</code></pre> <p><code>ConfigModel</code> also honors a additional <code>PicleConfig</code> parameters:</p> <ul> <li><code>config_file</code>: YAML config path (default: <code>configuration.yaml</code>)</li> <li><code>backup_on_save</code>: number of rotating backups to keep on commit (default: 5)</li> <li><code>commit_hook</code>: optional callable executed after a successful commit</li> </ul> <p>Notes:</p> <ul> <li><code>show configuration</code> prints the running config, <code>show changes</code> prints the staged diff.</li> <li><code>clear-changes</code> discards the staged temp file; <code>erase-configuration</code> stages an empty config.</li> <li><code>rollback &lt;n&gt;</code> loads <code>app_config.yaml.old&lt;n&gt;</code> into the temp file for review/commit.</li> </ul>"},{"location":"Getting%20Started/#multi-line-input","title":"Multi-line input","text":"<p>If a field sets <code>json_schema_extra={\"multiline\": True}</code>, the user can type <code>input</code> as the value to start multi-line collection. PICLE reads lines until EOF (Ctrl+D), then joins them with newlines and validates the result.</p>"},{"location":"Getting%20Started/#sample-shell-apps","title":"Sample shell apps","text":"<p>If you want copy/paste starting points, the repository includes a couple of small runnable examples:</p> <ul> <li><code>test/docs_sample_app_1.py</code>: a tiny \u201cshow version/clock\u201d shell</li> <li><code>test/config_app_example.py</code>: a complete <code>ConfigModel</code> configuration shell example</li> </ul>"},{"location":"api_reference/","title":"PICLE API reference","text":"<p>This page describes the configuration hooks PICLE reads from your Pydantic models and fields. It focuses on the parts you use when defining a shell (config, field metadata, execution, and output). For full API docs of <code>App</code> and built-in models, keep reading to the mkdocstrings reference at the bottom.</p>"},{"location":"api_reference/#picleconfig-model-level","title":"<code>PicleConfig</code> (model-level)","text":"<p>Any Pydantic model may define an inner <code>PicleConfig</code> class. PICLE reads attributes from it (when present). Only a few are required; most are optional quality-of-life switches.</p> <p><code>PicleConfig</code> is intentionally \u201copen-ended\u201d: the core <code>App</code> reads a known set of attributes (documented below), and specific built-in models may honor additional <code>PicleConfig</code> keys (for example, <code>ConfigModel</code>).</p> Name Meaning <code>ruler</code> Separator line char used by <code>cmd</code> help formatting (empty disables) <code>intro</code> Banner printed on shell start <code>prompt</code> Prompt string <code>use_rich</code> If <code>True</code> and Rich is installed, print via Rich console <code>newline</code> Output newline, default <code>\\r\\n</code> <code>completekey</code> Readline completion key name, default <code>tab</code> <code>pipe</code> Enables <code>|</code> and selects the pipe model (<code>\"self\"</code>, import string, or model class) <code>processors</code> List of callables applied to the first command result <code>outputter</code> Callable used to render output when not overridden <code>outputter_kwargs</code> Extra kwargs passed into <code>outputter</code> <p>Common additional flags used by the core shell logic:</p> Name Meaning <code>subshell</code> If <code>True</code>, navigating to this model with no args enters a subshell (prompt changes, model is pushed onto a stack) <code>methods_override</code> Dict of <code>{app_method_name: model_method_name}</code> used to override <code>App</code> methods at runtime"},{"location":"api_reference/#pipe-configuration","title":"Pipe configuration","text":"<p>If <code>pipe</code> is set, the <code>|</code> token becomes valid and starts a new \u201csegment\u201d. The next segment is parsed using the pipe model. <code>pipe</code> can be:</p> <pre><code>\"self\"                  re-use the current model as the pipe model\n\"some.module.Model\"     import a model by string\nSomeModelClass          use a model class directly\n</code></pre> <p>Example (enable pipe functions and post-process the first command):</p> <pre><code>from pydantic import BaseModel\nfrom picle.models import PipeFunctionsModel, Outputters\n\n\nclass ShellModel(BaseModel):\n    class PicleConfig:\n        prompt = \"picle#\"\n        intro = \"PICLE Sample app\"\n        pipe = PipeFunctionsModel\n        processors = [Outputters.outputter_json]\n</code></pre> <p><code>processors</code> run on the first command segment only (before any <code>|</code> segments).</p>"},{"location":"api_reference/#json_schema_extra-field-level","title":"<code>json_schema_extra</code> (field-level)","text":"<p>PICLE reads extra behavior from <code>Field(..., json_schema_extra={...})</code>.</p> <p>Note: command tokens come from the field name (or its <code>alias</code> / <code>serialization_alias</code>), not from the Pydantic class name.</p> Key Meaning <code>function</code> Name of a model <code>@staticmethod</code> to call when <code>run()</code> is absent <code>presence</code> Constant value used when field is referenced without a value <code>processors</code> List of callables applied to the command result <code>outputter</code> Callable that formats output for this field (overrides model outputter) <code>outputter_kwargs</code> Extra kwargs passed into <code>outputter</code> <code>multiline</code> If <code>True</code>, the literal value <code>input</code> triggers multi-line collection <code>root_model</code> If <code>True</code>, pass the app root model as <code>root_model=...</code> <code>picle_app</code> If <code>True</code>, pass the <code>App</code> instance as <code>picle_app=...</code> <code>use_parent_run</code> If <code>True</code> (default), and the leaf model has no <code>run()</code>, PICLE searches parent models for a <code>run()</code> to execute. If <code>False</code>, the command errors unless the leaf model defines <code>run()</code> or <code>function</code>."},{"location":"api_reference/#function-vs-run","title":"<code>function</code> vs <code>run()</code>","text":"<p>Execution is resolved like this:</p> <ol> <li>If the current model has <code>run</code>, PICLE calls <code>model.run(**kwargs)</code>.</li> <li>Otherwise, if the last referenced field sets <code>json_schema_extra={\"function\": \"method_name\"}</code>, PICLE calls <code>getattr(model, method_name)(**kwargs)</code>.</li> </ol> <p>This lets small models define many \u201ccommand -&gt; staticmethod\u201d fields, while larger models can centralize behavior in <code>run()</code>.</p>"},{"location":"api_reference/#callable-parameters-run-field-functions","title":"Callable parameters (<code>run()</code> / field functions)","text":"<p>PICLE builds <code>**kwargs</code> from collected field values and calls either <code>run()</code> or the field-level <code>function</code>. It can also inject extra context if (and only if) the callable declares a matching parameter name.</p> <ul> <li><code>root_model</code>: injected when the leaf field sets <code>json_schema_extra={\"root_model\": True}</code></li> <li><code>picle_app</code>: injected when the leaf field sets <code>json_schema_extra={\"picle_app\": True}</code></li> <li><code>shell_command</code>: injected when the callable signature includes <code>shell_command</code></li> </ul> <p><code>shell_command</code> is the parsed command context for the current segment: a list of model dicts produced by <code>parse_command()</code>. This is useful when your function needs to inspect the command path, model defaults, or other parsing details.</p>"},{"location":"api_reference/#pipes-positional-input-kwargs","title":"Pipes: positional input + kwargs","text":"<p>When the command contains pipes (<code>|</code>), execution happens left-to-right by segment:</p> <ul> <li>Segment 0: <code>run_function(**kwargs)</code></li> <li>Segment N (after <code>|</code>): <code>run_function(previous_result, **kwargs)</code></li> </ul> <p>If the segment\u2019s callable declares <code>shell_command</code>, PICLE passes it as a keyword argument for that segment.</p>"},{"location":"api_reference/#presence","title":"<code>presence</code>","text":"<p><code>presence</code> is useful for boolean-ish flags where you want the value to be set just by mentioning the field.</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Root(BaseModel):\n    verbose: bool = Field(\n        False,\n        description=\"Enable verbose mode\",\n        json_schema_extra={\"presence\": True},\n    )\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n</code></pre> <p>Example interaction:</p> <pre><code>picle#verbose\n{'verbose': True}\n</code></pre>"},{"location":"api_reference/#processors","title":"Processors","text":"<p>Processors are just functions that transform results. They run in order.</p> <pre><code>from typing import Any\nfrom pydantic import BaseModel, Field\nfrom picle.models import Outputters\n\n\nclass ModelShow(BaseModel):\n    data_pprint: Any = Field(\n        None,\n        description=\"Show structured data using pprint\",\n        json_schema_extra={\n            \"function\": \"produce_structured_data\",\n            \"processors\": [Outputters.outputter_pprint],\n        },\n    )\n\n    @staticmethod\n    def produce_structured_data():\n        return {\"some\": {\"nested\": {\"data\": None}}}\n</code></pre> <p>If you also set <code>PicleConfig.processors</code>, they run for the first segment after field-level processors.</p>"},{"location":"api_reference/#multi-line-input","title":"Multi-line input","text":"<p>If a field enables multi-line input, the user can type the literal value <code>input</code> to start collection. PICLE reads lines until EOF (Ctrl+D) and uses the collected text (joined by <code>\\n</code>) as the field value.</p> <pre><code>from typing import Any\nfrom pydantic import BaseModel, Field, StrictStr\n\n\nclass TestMultilineInput(BaseModel):\n    data: StrictStr = Field(\n        None,\n        description=\"Multi line string\",\n        json_schema_extra={\"multiline\": True},\n    )\n    arg: Any = Field(None, description=\"Some field\")\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n\n\nclass Root(BaseModel):\n    test_multiline_input: TestMultilineInput = Field(\n        None,\n        description=\"Multi-line input demo\",\n    )\n</code></pre> <p>Help shows the <code>input</code> option when appropriate:</p> <pre><code>picle#test_multiline_input data ?\n &lt;'data' value&gt;    Multi line string\n input             Collect value using multi line input mode\n</code></pre> <p>Invoking multi-line collection:</p> <pre><code>picle#test_multiline_input data input arg foo\nEnter lines and hit Ctrl+D to finish multi line input\nline 1\nline 2\n&lt;Ctrl+D&gt;\n</code></pre>"},{"location":"api_reference/#result-specific-outputters","title":"Result-specific outputters","text":"<p>Sometimes a single model-level outputter is not enough. If you need to choose an outputter based on runtime data, return a tuple from <code>run()</code>:</p> <pre><code>(result, outputter)\n(result, outputter, outputter_kwargs)\n</code></pre> <p>This overrides model and field outputters for that specific execution.</p>"},{"location":"api_reference/#configmodel-configuration-shells","title":"<code>ConfigModel</code> (configuration shells)","text":"<p>PICLE ships a helper base model for \u201cconfiguration-mode\u201d shells: <code>picle.models.ConfigModel</code>. It implements a common workflow:</p> <ul> <li>Load configuration from YAML (optional dependency: <code>pyyaml</code>)</li> <li>Stage edits into a temporary file (<code>&lt;config_file&gt;.tmp</code>)</li> <li>Review staged changes (<code>show changes</code>) and commit them (<code>commit</code>)</li> <li>Keep rotating backups on commit (<code>.old1</code>, <code>.old2</code>, ...)</li> <li>Roll back by loading a backup into the temp file (<code>rollback &lt;n&gt;</code>) and then committing</li> </ul>"},{"location":"api_reference/#configmodelpicleconfig-keys","title":"<code>ConfigModel.PicleConfig</code> keys","text":"<p><code>ConfigModel</code> reads additional settings from the concrete model\u2019s <code>PicleConfig</code>. These keys are only honored by <code>ConfigModel</code> (the core <code>App</code> ignores them):</p> Name Meaning <code>config_file</code> Path to the YAML config file (default: <code>configuration.yaml</code>) <code>backup_on_save</code> How many <code>.oldN</code> backups to keep when committing (0 disables backups) <code>commit_hook</code> Optional callable invoked after a successful commit"},{"location":"api_reference/#typical-command-flow","title":"Typical command flow","text":"<p>Assuming you mount a <code>ConfigModel</code>-derived model under <code>configure_terminal</code>:</p> <pre><code>picle#configure_terminal\n... (optionally enters a subshell if `PicleConfig.subshell = True`)\n\n...#logging terminal severity debug\nConfiguration updated (uncommitted). Use 'commit' to save or 'show changes' to review.\n\n...#show changes\n--- app_config.yaml\n+++ app_config.yaml.tmp\n...\n\n...#commit\nConfiguration committed successfully\n</code></pre>"},{"location":"api_reference/#mountingremoving-models-at-runtime","title":"Mounting/removing models at runtime","text":"<p><code>App</code> can add/remove models to the root tree:</p> <pre><code>from pydantic import BaseModel, Field, StrictStr\nfrom picle import App\n\n\nclass Mounted(BaseModel):\n    param: StrictStr = Field(None, description=\"Param string\")\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n\n\nclass Root(BaseModel):\n    command: StrictStr = Field(None, description=\"Some command\")\n\n\nshell = App(Root)\nshell.model_mount(Mounted, [\"another_command\"])\nshell.model_remove([\"another_command\"])\n</code></pre> <p>Notes:</p> <ul> <li><code>path</code> may be a list of segments or a single string.</li> <li><code>model_mount</code> can only mount under an existing path, except for the final segment (which is created).</li> <li>Mounted fields are added to the root model\u2019s <code>model_fields</code> and participate in completion/help.</li> </ul>"},{"location":"api_reference/#picle-app","title":"PICLE App","text":""},{"location":"api_reference/#picle.App","title":"<code>picle.App(root, stdin=None, stdout=None)</code>","text":"<p>               Bases: <code>Cmd</code></p> <p>PICLE App class to construct shell.</p> <p>Parameters:</p> <ul> <li> <code>root</code>           \u2013            <p>Root/Top Pydantic model</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def __init__(self, root, stdin=None, stdout=None):\n    self.root = root\n    self.shell = self.root.model_construct()\n    self.shell_defaults = {}\n    self.shells = [self.shell]\n\n    # extract configuration from shell model\n    if hasattr(self.shell, \"PicleConfig\"):\n        self.ruler = getattr(self.shell.PicleConfig, \"ruler\", self.ruler)\n        self.intro = getattr(self.shell.PicleConfig, \"intro\", self.intro)\n        self.prompt = getattr(self.shell.PicleConfig, \"prompt\", self.prompt)\n        self.newline = getattr(self.shell.PicleConfig, \"newline\", self.newline)\n        self.use_rich = getattr(self.shell.PicleConfig, \"use_rich\", self.use_rich)\n        self.completekey = getattr(\n            self.shell.PicleConfig, \"completekey\", self.completekey\n        )\n\n        # mount override methods\n        if hasattr(self.shell.PicleConfig, \"methods_override\"):\n            for (\n                method_name,\n                override,\n            ) in self.shell.PicleConfig.methods_override.items():\n                setattr(self, method_name, getattr(self.shell, override))\n\n    # mount models\n    self.model_mount(MAN, [\"man\"], \"Manual/documentation functions\")\n\n    super(App, self).__init__(stdin=stdin, stdout=stdout)\n</code></pre>"},{"location":"api_reference/#picle.App.completedefault","title":"<code>picle.App.completedefault(text: str, line: str, begidx: int, endidx: int) -&gt; list[str]</code>","text":"<p>Return completions for every command parameter after the first one.</p> <p>Called by :mod:<code>cmd</code> on a tab-key hit for arguments beyond the initial command keyword.</p> Source code in <code>picle\\picle.py</code> <pre><code>def completedefault(\n    self, text: str, line: str, begidx: int, endidx: int\n) -&gt; list[str]:\n    \"\"\"\n    Return completions for every command parameter after the first one.\n\n    Called by :mod:`cmd` on a tab-key hit for arguments beyond the\n    initial command keyword.\n    \"\"\"\n    fieldnames = []\n    try:\n        command_models = self.parse_command(line, is_help=True)\n        last_model = command_models[-1][-1][\"model\"]\n        # check if last model has fields collected\n        if command_models[-1][-1][\"fields\"]:\n            last_field_name = command_models[-1][-1][\"fields\"][-1][\"name\"]\n            last_field = model_fields(last_model)[last_field_name]\n            last_field_value = command_models[-1][-1][\"fields\"][-1][\"values\"]\n            fparam = self._get_field_params(last_field)\n            if isinstance(last_field_value, list):\n                last_field_value = last_field_value[-1]\n            elif last_field_value == ...:\n                last_field_value = \"\"\n            # check if need to extract enum values\n            if isinstance(last_field.annotation, enum.EnumMeta):\n                fieldnames = [\n                    str(i.value)\n                    for i in last_field.annotation\n                    if str(i.value).startswith(last_field_value)\n                    and i.value != last_field_value\n                ]\n            # check if model has method to source field choices\n            elif hasattr(last_model, f\"source_{last_field_name}\"):\n                fieldnames = getattr(last_model, f\"source_{last_field_name}\")()\n                # handle partial match\n                if last_field_value not in fieldnames:\n                    fieldnames = [\n                        str(i)\n                        for i in fieldnames\n                        if str(i).startswith(last_field_value)\n                    ]\n                # remove already collected values from choice\n                collected_values = command_models[-1][-1][\"fields\"][-1][\"values\"]\n                if collected_values is not ...:\n                    fieldnames = [\n                        i for i in fieldnames if i not in collected_values\n                    ]\n            # auto complete 'input' for multi-line input mode\n            elif fparam.get(\"multiline\") is True:\n                if (\n                    \"input\".startswith(last_field_value)\n                    and last_field_value != \"input\"\n                ):\n                    fieldnames = [\"input\"]\n        # return a list of all model fields\n        else:\n            if line.endswith(\" \"):\n                for name, f in model_fields(last_model).items():\n                    if f.alias:\n                        fieldnames.append(f.alias)\n                    elif f.serialization_alias:\n                        fieldnames.append(f.serialization_alias)\n                    else:\n                        fieldnames.append(name)\n            else:\n                last_fieldname = command_models[-1][-1][\"parameter\"]\n                fieldnames.append(last_fieldname)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        for name, f in model_fields(model[\"model\"]).items():\n            # skip fields with already collected values from complete prompt\n            if any(\n                collected_field[\"name\"] == name\n                for collected_field in model[\"fields\"]\n                if collected_field[\"values\"] is not ...\n            ):\n                continue\n            # handle Enum fields options\n            elif any(\n                collected_field[\"name\"] == name\n                for collected_field in model[\"fields\"]\n            ) and isinstance(f.annotation, enum.EnumMeta):\n                fieldnames = [\n                    str(i.value)\n                    for i in f.annotation\n                    if str(i.value).startswith(parameter)\n                ]\n                break\n            elif f.alias and f.alias.startswith(parameter):\n                fieldnames.append(f.alias)\n            elif f.serialization_alias and f.serialization_alias.startswith(\n                parameter\n            ):\n                fieldnames.append(f.serialization_alias)\n            elif name.startswith(parameter):\n                fieldnames.append(name)\n    except FieldKeyError:\n        pass\n    except:\n        tb = traceback.format_exc()\n        self.write(tb)\n\n    return sorted([f\"{i} \" for i in fieldnames])\n</code></pre>"},{"location":"api_reference/#picle.App.completenames","title":"<code>picle.App.completenames(text: str, line: str, begidx: int, endidx: int) -&gt; list[str]</code>","text":"<p>Return completions for the very first command parameter.</p> <p>Called by :mod:<code>cmd</code> on a tab-key hit for the initial keyword.</p> Source code in <code>picle\\picle.py</code> <pre><code>def completenames(\n    self, text: str, line: str, begidx: int, endidx: int\n) -&gt; list[str]:\n    \"\"\"\n    Return completions for the very first command parameter.\n\n    Called by :mod:`cmd` on a tab-key hit for the initial keyword.\n    \"\"\"\n    fieldnames = []\n    # collect global methods\n    for method_name in dir(self):\n        if method_name.startswith(\"do_\"):\n            name = method_name.replace(\"do_\", \"\")\n            if name.startswith(line):\n                fieldnames.append(name)\n    # collect model arguments\n    try:\n        command_models = self.parse_command(line, is_help=True)\n        fieldnames.extend(model_fields(command_models[-1][-1][\"model\"]))\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        for name, f in model_fields(model[\"model\"]).items():\n            display = f.alias or f.serialization_alias or name\n            if display.startswith(parameter):\n                fieldnames.append(display)\n    except FieldKeyError:\n        pass\n    return sorted([f\"{i} \" for i in fieldnames])\n</code></pre>"},{"location":"api_reference/#picle.App.default","title":"<code>picle.App.default(line: str) -&gt; Optional[bool]</code>","text":"<p>Process a command line when no matching <code>do_*</code> method is found.</p> Source code in <code>picle\\picle.py</code> <pre><code>@run_print_exception\ndef default(self, line: str) -&gt; Optional[bool]:\n    \"\"\"Process a command line when no matching ``do_*`` method is found.\"\"\"\n    ret = False\n    outputter = True  # use default outputter - self.write\n    outputter_kwargs = {}\n    line = line.strip()\n\n    if line.endswith(\"?\"):\n        self.process_help_command(line)\n    else:\n        try:\n            command_models = self.parse_command(line, collect_multiline=True)\n        except FieldLooseMatchOnly as e:\n            model, parameter = e.args\n            fields = [\n                f.alias or f.serialization_alias or name\n                for name, f in model_fields(model[\"model\"]).items()\n                if name.startswith(parameter)\n                or (f.alias and f.alias.startswith(parameter))\n                or (\n                    f.serialization_alias\n                    and f.serialization_alias.startswith(parameter)\n                )\n            ]\n            self.write(\n                f\"Incomplete command, possible completions: {', '.join(fields)}\"\n            )\n        except FieldKeyError as e:\n            model, parameter = e.args\n            self.write(\n                f\"Incorrect command, '{parameter}' not part of \"\n                f\"'{self._get_model_name(model)}' model fields\"\n            )\n        except ValidationError as e:\n            self.write(e)\n        else:\n            # go over collected commands separated by pipe\n            for index, command in enumerate(command_models):\n                json_schema_extra = {}\n                method_name = None\n                # collect arguments\n                command_arguments = {\n                    f[\"name\"]: f[\"values\"]\n                    for model in command\n                    for f in model[\"fields\"]\n                    if f[\"values\"] is not ...\n                }\n                # collect command defaults\n                command_defaults = {}\n                for cmd in command:\n                    command_defaults.update(cmd.get(\"defaults\", {}))\n                model = command[-1][\"model\"]\n                picle_config = getattr(model, \"PicleConfig\", None)\n\n                # check if model has subshell and no arguments provided - enter subshell\n                if (\n                    not command_arguments\n                    and getattr(picle_config, \"subshell\", None) is True\n                ):\n                    for item in command[:-1]:\n                        m = item[\"model\"]\n                        self.defaults_update(m)\n                        if (\n                            getattr(\n                                getattr(m, \"PicleConfig\", None), \"subshell\", None\n                            )\n                            is True\n                            and m not in self.shells\n                        ):\n                            self.shells.append(m)\n                    self.prompt = getattr(picle_config, \"prompt\", self.prompt)\n                    self.shell = model\n                    self.shells.append(self.shell)\n                    continue\n\n                # resolve run function - prefer json_schema_extra \"function\", fallback to \"run\" method, search parents for \"run\"\n                if command[-1][\"fields\"]:\n                    json_schema_extra = command[-1][\"fields\"][-1][\n                        \"json_schema_extra\"\n                    ]\n                if callable(json_schema_extra.get(\"function\")):\n                    run_function = json_schema_extra[\"function\"]\n                else:\n                    method_name = json_schema_extra.get(\"function\", \"run\")\n                    if hasattr(model, method_name):\n                        run_function = getattr(model, method_name)\n                    elif method_name != \"run\":\n                        ret = f\"Model '{model.__name__}' has no '{method_name}' method defined\"\n                        break\n                    elif json_schema_extra.get(\"use_parent_run\", True):\n                        run_function = self._find_parent_run(command)\n                        if run_function is None:\n                            self.defaults_pop(model)\n                            ret = f\"Incorrect command for '{model.__name__}', model parents have no 'run' method to execute command\"\n                            break\n                    else:\n                        self.defaults_pop(model)\n                        ret = f\"Incorrect command for '{model.__name__}', model has no method to execute command\"\n                        break\n\n                self._validate_values(command)\n\n                # build kwargs and call the method\n                if index == 0:\n                    kw = {\n                        **self.shell_defaults,\n                        **command_defaults,\n                        **command_arguments,\n                    }\n                    if json_schema_extra.get(\"root_model\"):\n                        kw[\"root_model\"] = self.root\n                    if json_schema_extra.get(\"picle_app\"):\n                        kw[\"picle_app\"] = self\n                    if callable_expects_argument(run_function, \"shell_command\"):\n                        kw[\"shell_command\"] = command\n                    ret = run_function(**kw)\n                else:\n                    kw = {**command_defaults, **command_arguments}\n                    if callable_expects_argument(run_function, \"shell_command\"):\n                        kw[\"shell_command\"] = command\n                    ret = run_function(ret, **kw)\n\n                # apply field-level processors\n                for processor in json_schema_extra.get(\"processors\", []):\n                    if callable(processor):\n                        ret = processor(ret)\n\n                # apply PicleConfig processors for first command only\n                if index == 0:\n                    for processor in getattr(picle_config, \"processors\", []):\n                        if callable(processor):\n                            ret = processor(ret)\n\n                # resolve outputter: from return tuple, field definition, or PicleConfig\n                if isinstance(ret, tuple) and len(ret) == 2:\n                    ret, outputter = ret\n                    outputter_kwargs = {}\n                elif isinstance(ret, tuple) and len(ret) == 3:\n                    ret, outputter, outputter_kwargs = ret\n                elif json_schema_extra.get(\"outputter\"):\n                    outputter = json_schema_extra[\"outputter\"]\n                    outputter_kwargs = json_schema_extra.get(\"outputter_kwargs\", {})\n                elif picle_config and hasattr(picle_config, \"outputter\"):\n                    outputter = picle_config.outputter\n                    outputter_kwargs = getattr(picle_config, \"outputter_kwargs\", {})\n\n    # returning True will end the shell - exit\n    if ret is True:\n        return True\n\n    if ret:\n        if callable(outputter):\n            self.write(outputter(ret, **outputter_kwargs))\n        elif outputter is True:\n            self.write(ret)\n</code></pre>"},{"location":"api_reference/#picle.App.defaults_pop","title":"<code>picle.App.defaults_pop(model: Any) -&gt; None</code>","text":"<p>Remove the given model's field names from :attr:<code>shell_defaults</code>.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def defaults_pop(self, model: Any) -&gt; None:\n    \"\"\"\n    Remove the given model's field names from :attr:`shell_defaults`.\n\n    :param model: Pydantic model class or instance.\n    \"\"\"\n    for name in model_fields(model).keys():\n        self.shell_defaults.pop(name, None)\n</code></pre>"},{"location":"api_reference/#picle.App.defaults_set","title":"<code>picle.App.defaults_set(model: Any) -&gt; None</code>","text":"<p>Replace :attr:<code>shell_defaults</code> with the given model's defaults.</p> <p>Clears the existing defaults and populates them from model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def defaults_set(self, model: Any) -&gt; None:\n    \"\"\"\n    Replace :attr:`shell_defaults` with the given model's defaults.\n\n    Clears the existing defaults and populates them from *model*.\n\n    :param model: Pydantic model class or instance.\n    \"\"\"\n    self.shell_defaults.clear()\n    self.defaults_update(model)\n</code></pre>"},{"location":"api_reference/#picle.App.defaults_update","title":"<code>picle.App.defaults_update(model: Any) -&gt; None</code>","text":"<p>Merge the given model's default field values into :attr:<code>shell_defaults</code>.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def defaults_update(self, model: Any) -&gt; None:\n    \"\"\"\n    Merge the given model's default field values into :attr:`shell_defaults`.\n\n    :param model: Pydantic model class or instance.\n    \"\"\"\n    self.shell_defaults.update(self.extract_model_defaults(model))\n</code></pre>"},{"location":"api_reference/#picle.App.do_cls","title":"<code>picle.App.do_cls(arg: str) -&gt; None</code>","text":"<p>Clear the terminal screen.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_cls(self, arg: str) -&gt; None:\n    \"\"\"Clear the terminal screen.\"\"\"\n    if \"?\" in arg:\n        self.write(\" cls    Clear shell Screen\")\n    else:\n        if \"LINUX\" in platform.system().upper():\n            os.system(\"clear\")\n        elif \"WINDOWS\" in platform.system().upper():\n            os.system(\"cls\")\n</code></pre>"},{"location":"api_reference/#picle.App.do_end","title":"<code>picle.App.do_end(arg: str) -&gt; Optional[bool]</code>","text":"<p>Exit the application entirely.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_end(self, arg: str) -&gt; Optional[bool]:\n    \"\"\"Exit the application entirely.\"\"\"\n    if \"?\" in arg:\n        self.write(\" end    Exit application\")\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/#picle.App.do_exit","title":"<code>picle.App.do_exit(arg: str) -&gt; Optional[bool]</code>","text":"<p>Exit current shell or terminate if at the top level.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_exit(self, arg: str) -&gt; Optional[bool]:\n    \"\"\"Exit current shell or terminate if at the top level.\"\"\"\n    if \"?\" in arg:\n        self.write(\" exit    Exit current shell\")\n    else:\n        # delete defaults for closing shell\n        self.defaults_pop(self.shells[-1])\n        _ = self.shells.pop(-1)\n        if self.shells:\n            self.shell = self.shells[-1]\n            if hasattr(self.shell, \"PicleConfig\") and getattr(\n                self.shell.PicleConfig, \"prompt\"\n            ):\n                self.prompt = self.shell.PicleConfig.prompt\n            if len(self.shells) == 1:  # check if reached top shell\n                self.defaults_set(self.shell)\n        else:\n            return True\n</code></pre>"},{"location":"api_reference/#picle.App.do_help","title":"<code>picle.App.do_help(arg: str) -&gt; None</code>","text":"<p>Print help message for the given command or model.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_help(self, arg: str) -&gt; None:\n    \"\"\"Print help message for the given command or model.\"\"\"\n    try:\n        command_models = self.parse_command(arg.strip(\"?\"), is_help=True)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        self.print_model_help([[model]], verbose=..., match=parameter)\n        return\n    except FieldKeyError as e:\n        model, parameter = e.args\n        self.write(\n            f\"Incorrect command, '{parameter}' not part of \"\n            f\"'{self._get_model_name(model)}' model fields\"\n        )\n        return\n    help_msg, width = self.print_model_help(\n        command_models,\n        verbose=arg.strip().endswith(\"?\"),\n        print_help=False,\n    )\n    # print help for global top commands\n    if len(arg.strip().split(\" \")) == 1:\n        lines = {}  # dict of {cmd: cmd_help}\n        for method_name in dir(self):\n            if method_name.startswith(\"do_\"):\n                name = method_name.replace(\"do_\", \"\")\n                lines[name] = getattr(self, method_name).__doc__\n                width = max(width, len(name))\n        if lines:\n            for k, v in lines.items():\n                padding = \" \" * (width - len(k)) + (\" \" * 4)\n                help_msg.append(f\" {k}{padding}{v}\")\n    self.write(self.newline.join(help_msg))\n</code></pre>"},{"location":"api_reference/#picle.App.do_pwd","title":"<code>picle.App.do_pwd(arg: str) -&gt; None</code>","text":"<p>Print the current shell path from root.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_pwd(self, arg: str) -&gt; None:\n    \"\"\"Print the current shell path from root.\"\"\"\n    if \"?\" in arg:\n        self.write(\" pwd    Print current shell path\")\n    else:\n        path = [\"Root\"]\n        for shell in self.shells[1:]:\n            path.append(shell.__name__)\n        self.write(\"-&gt;\".join(path))\n</code></pre>"},{"location":"api_reference/#picle.App.do_top","title":"<code>picle.App.do_top(arg: str) -&gt; None</code>","text":"<p>Exit to top shell, resetting the shell stack.</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_top(self, arg: str) -&gt; None:\n    \"\"\"Exit to top shell, resetting the shell stack.\"\"\"\n    if \"?\" in arg:\n        self.write(\" top    Exit to top shell\")\n    else:\n        self.shell = self.shells[0]\n        if hasattr(self.shell, \"PicleConfig\") and getattr(\n            self.shell.PicleConfig, \"prompt\"\n        ):\n            self.prompt = self.shell.PicleConfig.prompt\n        while self.shells:\n            _ = self.shells.pop()\n        self.shells.append(self.shell)\n        # set shell defaults\n        self.defaults_set(self.shell)\n</code></pre>"},{"location":"api_reference/#picle.App.emptyline","title":"<code>picle.App.emptyline() -&gt; None</code>","text":"<p>Override empty line method to not run last command</p> Source code in <code>picle\\picle.py</code> <pre><code>def emptyline(self) -&gt; None:\n    \"\"\"Override empty line method to not run last command\"\"\"\n    return None\n</code></pre>"},{"location":"api_reference/#picle.App.extract_model_defaults","title":"<code>picle.App.extract_model_defaults(model: Any) -&gt; dict</code>","text":"<p>Extract non-None default values from a Pydantic model's fields.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Any</code>)           \u2013            <p>Pydantic model class or instance to extract defaults from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>dictionary mapping field names to their default values.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def extract_model_defaults(self, model: Any) -&gt; dict:\n    \"\"\"\n    Extract non-None default values from a Pydantic model's fields.\n\n    :param model: Pydantic model class or instance to extract defaults from.\n    :return: dictionary mapping field names to their default values.\n    \"\"\"\n    ret = {}\n    # extract default values from model fields\n    for name, field in model_fields(model).items():\n        # skip non Field references e.g. to other models\n        if not isinstance(field, FieldInfo):\n            continue\n        # skip required Fields\n        if field.is_required():\n            continue\n        # ignore None default values\n        if field.get_default() is None:\n            continue\n        default = field.get_default()\n        # convert Enum defaults to their plain value\n        if isinstance(default, enum.Enum):\n            default = default.value\n        ret[name] = default\n\n    return ret\n</code></pre>"},{"location":"api_reference/#picle.App.model_mount","title":"<code>picle.App.model_mount(model: ModelMetaclass, path: Union[str, list[str]], description: str = None, default=None, **kwargs: dict) -&gt; None</code>","text":"<p>Method to mount pydantic model at provided path in relation to the root model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>ModelMetaclass</code>)           \u2013            <p>Pydantic model to mount.</p> </li> <li> <code>path</code>               (<code>Union[str, list[str]]</code>)           \u2013            <p>List of path segments to mount the model.</p> </li> <li> <code>description</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Description of the model.</p> </li> <li> <code>default</code>           \u2013            <p>Default value for the model.</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the FieldInfo.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def model_mount(\n    self,\n    model: ModelMetaclass,\n    path: Union[str, list[str]],\n    description: str = None,\n    default=None,\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"\n    Method to mount pydantic model at provided path in relation to the root model.\n\n    :param model: Pydantic model to mount.\n    :param path: List of path segments to mount the model.\n    :param description: Description of the model.\n    :param default: Default value for the model.\n    :param kwargs: Additional keyword arguments for the FieldInfo.\n    \"\"\"\n    if isinstance(path, str):\n        path = [path.strip()]\n    parent_model = self.root\n    while path:\n        mount_name = path.pop(0)\n        if mount_name in parent_model.model_fields:\n            parent_model = parent_model.model_fields[mount_name].annotation\n        else:\n            # handle when not all path items before last one are in models tree\n            if len(path) &gt; 0:\n                raise KeyError(\n                    f\"'{mount_name}' not part of '{parent_model}' model fields, but remaining path still not empty - {path}\"\n                )\n            parent_model.model_fields[mount_name] = FieldInfo(\n                annotation=model,\n                required=False,\n                description=description,\n                default=default,\n                **kwargs,\n            )\n            break\n</code></pre>"},{"location":"api_reference/#picle.App.model_remove","title":"<code>picle.App.model_remove(path: list[str]) -&gt; None</code>","text":"<p>Method to remove pydantic model at provided path in relation to the root model.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>list[str]</code>)           \u2013            <p>List of path segments to remove the model.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def model_remove(self, path: list[str]) -&gt; None:\n    \"\"\"\n    Method to remove pydantic model at provided path in relation to the root model.\n\n    :param path: List of path segments to remove the model.\n    \"\"\"\n    if isinstance(path, str):\n        path = [path.strip()]\n    parent_model = self.root\n    while path:\n        mount_name = path.pop(0)\n        if mount_name in parent_model.model_fields:\n            if len(path) == 0:\n                parent_model = parent_model.model_fields.pop(mount_name)\n            else:\n                parent_model = parent_model.model_fields[mount_name].annotation\n        else:\n            raise KeyError(\n                f\"Failed to remove model at path '{mount_name}', parent model: '{parent_model}'\"\n            )\n</code></pre>"},{"location":"api_reference/#picle.App.parse_command","title":"<code>picle.App.parse_command(command: str, collect_multiline: bool = False, is_help: bool = False) -&gt; list</code>","text":"<p>Function to parse command string and construct list of model references and fields values.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>command string to parse through</p> </li> <li> <code>is_help</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>indicates that parsing help command or tab completion command, if set to True disables <code>presence</code> argument handling for last field</p> </li> <li> <code>collect_multiline</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>enables multiple input collection for fields</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>returns a list of lists of dictionaries with collected models details each dictionary containing <code>model</code>, <code>fields</code> and <code>parameter</code> keys.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def parse_command(\n    self, command: str, collect_multiline: bool = False, is_help: bool = False\n) -&gt; list:\n    \"\"\"\n    Function to parse command string and construct list of model\n    references and fields values.\n\n    :param command: command string to parse through\n    :param is_help: indicates that parsing help command or tab completion command,\n        if set to True disables ``presence`` argument handling for last field\n    :param collect_multiline: enables multiple input collection for fields\n    :return: returns a list of lists of dictionaries with collected models details\n        each dictionary containing ``model``, ``fields`` and ``parameter`` keys.\n    \"\"\"\n    current_model = {\n        \"model\": self.shell,\n        \"fields\": [],\n        \"parameter\": ...,\n        \"defaults\": self.extract_model_defaults(self.shell),\n    }\n    current_field = {}\n    models = [current_model]\n    parameters = [i for i in command.split(\" \") if i.strip()]\n    ret = [models]\n\n    # iterate over command parameters and decide if its a reference\n    # to a model or model's field value\n    while parameters:\n        parameter = parameters.pop(0)\n\n        # handle pipe - \"|\"\n        if parameter == \"|\":\n            pipe_config = getattr(\n                getattr(current_model[\"model\"], \"PicleConfig\", None),\n                \"pipe\",\n                None,\n            )\n            if not pipe_config:\n                log.error(\n                    f\"'{current_model['model'].__name__}' does not support pipe handling\"\n                )\n                break\n            # resolve pipe model\n            if pipe_config == \"self\":\n                pipe_model = current_model[\"model\"]\n            # import pipe model from module path string\n            elif isinstance(pipe_config, str):\n                # rpartition - returns a tuple of (before_last_dot, dot, after_last_dot)\n                module_path, _, class_name = pipe_config.rpartition(\".\")\n                module = __import__(module_path, fromlist=[\"\"])\n                pipe_model = getattr(module, class_name)\n            else:\n                pipe_model = pipe_config\n            current_model = {\n                \"model\": pipe_model,\n                \"fields\": [],\n                \"parameter\": parameter,\n            }\n            models = [current_model]\n            ret.append(models)\n\n        # collect JSON dictionary or list string\n        elif parameter.strip().startswith((\"{\", \"[\")) and current_field:\n            close = \"}\" if parameter.strip().startswith(\"{\") else \"]\"\n            value_items = [parameter]\n            while parameters:\n                parameter = parameters.pop(0)\n                value_items.append(parameter)\n                if parameter.strip().endswith(close):\n                    break\n            self._save_collected_value(current_field, \" \".join(value_items))\n\n        # collect quoted field value (single or double quotes)\n        elif ('\"' in parameter or \"'\" in parameter) and current_field:\n            quote = '\"' if '\"' in parameter else \"'\"\n            value_items = [parameter.replace(quote, \"\")]\n            if parameter.count(quote) != 2:\n                while parameters:\n                    parameter = parameters.pop(0)\n                    value_items.append(parameter.replace(quote, \"\"))\n                    if quote in parameter:\n                        break\n            self._save_collected_value(current_field, \" \".join(value_items))\n\n        # handle exact match to model field by name, alias, or serialization_alias\n        elif resolved := self._resolve_field(current_model[\"model\"], parameter):\n            parameter, field = resolved\n            # record presence for previous field before moving on\n            if current_field.get(\n                \"values\"\n            ) is ... and \"presence\" in current_field.get(\"json_schema_extra\", {}):\n                self._save_collected_value(\n                    current_field,\n                    current_field[\"json_schema_extra\"][\"presence\"],\n                )\n            # handle next level model reference\n            if isinstance(field.annotation, ModelMetaclass):\n                current_model = {\n                    \"model\": field.annotation,\n                    \"fields\": [],\n                    \"parameter\": parameter,\n                }\n                models.append(current_model)\n                current_field = {}\n                if len(ret) == 1:\n                    current_model[\"defaults\"] = self.extract_model_defaults(\n                        field.annotation\n                    )\n            # handle actual field reference\n            elif isinstance(field, FieldInfo):\n                current_field = {\n                    \"name\": parameter,\n                    \"values\": ...,\n                    \"field\": field,\n                    \"json_schema_extra\": field.json_schema_extra or {},\n                }\n                # find and replace default value if present\n                for idx, f in enumerate(current_model[\"fields\"]):\n                    if f[\"name\"] == current_field[\"name\"]:\n                        current_model[\"fields\"][idx] = current_field\n                        break\n                else:\n                    current_model[\"fields\"].append(current_field)\n            else:\n                raise TypeError(\n                    f\"Unsupported pydantic field type: '{type(field.annotation)}', \"\n                    f\"parameter: '{parameter}', command: '{command}', current model: \"\n                    f\"'{current_model['model']}'\"\n                )\n\n        # check if last field is an Enumerator\n        elif current_field and isinstance(\n            current_field[\"field\"].annotation, enum.EnumMeta\n        ):\n            if any(\n                str(i.value) == parameter for i in current_field[\"field\"].annotation\n            ):\n                self._save_collected_value(current_field, parameter)\n            elif any(\n                str(i.value).startswith(parameter)\n                for i in current_field[\"field\"].annotation\n            ):\n                raise FieldLooseMatchOnly(current_model, parameter)\n\n        # check if parameter partially matches any model field\n        elif self._has_partial_match(current_model[\"model\"], parameter):\n            raise FieldLooseMatchOnly(current_model, parameter)\n\n        # parameter is a value, save it to current field\n        elif current_field:\n            self._save_collected_value(current_field, parameter)\n        else:\n            raise FieldKeyError(current_model, parameter)\n    # check presence for last parameter is not is_help\n    if (\n        is_help is False\n        and current_field.get(\"values\") is ...\n        and \"presence\" in current_field[\"json_schema_extra\"]\n    ):\n        value = current_field[\"json_schema_extra\"][\"presence\"]\n        self._save_collected_value(current_field, value)\n\n    # iterate over collected models and fields to see\n    # if need to collect multi-line input\n    if collect_multiline:\n        for command_models in ret:\n            for model in command_models:\n                for field in model[\"fields\"]:\n                    self._collect_multiline(field)\n\n    return ret\n</code></pre>"},{"location":"api_reference/#picle.App.print_model_help","title":"<code>picle.App.print_model_help(models: list, verbose: bool = False, match: Optional[str] = None, print_help: bool = True) -&gt; Optional[tuple[list[str], int]]</code>","text":"<p>Function to form and print help message for model fields.</p> <p>Parameters:</p> <ul> <li> <code>match</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>only collect help for fields that start with <code>match</code> string</p> </li> <li> <code>print_help</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if true prints help, return tuple of help lines list and width of longest line</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def print_model_help(\n    self,\n    models: list,\n    verbose: bool = False,\n    match: Optional[str] = None,\n    print_help: bool = True,\n) -&gt; Optional[tuple[list[str], int]]:\n    \"\"\"\n    Function to form and print help message for model fields.\n\n    :param match: only collect help for fields that start with ``match`` string\n    :param print_help: if true prints help, return tuple of help lines\n        list and width of longest line\n    \"\"\"\n    model = models[-1][-1]  # get last model\n    last_field = model[\"fields\"][-1] if model[\"fields\"] else None\n    fparam = self._get_field_params(last_field)\n    lines = {}  # dict of {cmd: cmd_help}\n    width = 0  # record longest command width for padding\n    # print help message only for last collected field\n    if last_field and last_field[\"values\"] == ...:\n        field = last_field[\"field\"]\n        json_schema_extra = last_field[\"json_schema_extra\"]\n        name = f\"&lt;'{last_field['name']}' value&gt;\"\n        # check if field referencing function\n        if json_schema_extra.get(\"function\"):\n            lines[name] = f\"{field.description}\"\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Execute command\"\n        # add options for enumerations\n        elif isinstance(field.annotation, enum.EnumMeta):\n            options = [i.value for i in field.annotation]\n            lines[name] = \", \".join([str(i) for i in options])\n        # check if model has method to source field choices\n        elif hasattr(model[\"model\"], f\"source_{last_field['name']}\"):\n            options = getattr(model[\"model\"], f\"source_{last_field['name']}\")()\n            lines[name] = \", \".join([str(i) for i in options])\n        else:\n            lines[name] = f\"{field.description}\"\n            # check if field supports multiline input\n            if fparam.get(\"multiline\") is True:\n                lines[\"input\"] = \"Collect value using multi line input mode\"\n            if verbose:\n                lines[name] += (\n                    f\"; default '{field.get_default()}', type '{str(field.annotation)}', \"\n                    f\"is required - {field.is_required()}\"\n                )\n    # collect help message for all fields of this model\n    else:\n        # check if model supports subshell\n        if (\n            hasattr(model[\"model\"], \"PicleConfig\")\n            and getattr(model[\"model\"].PicleConfig, \"subshell\", None) is True\n            # exclude &lt;ENTER&gt; if already in model's shell\n            and not self.shells[-1] == model[\"model\"]\n        ):\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Enter command subshell\"\n        # iterate over model fields\n        for name, field in model_fields(model[\"model\"]).items():\n            # skip fields that already have values\n            if any(f[\"name\"] == name for f in model[\"fields\"]):\n                continue\n            # check if field has alias\n            if field.alias:\n                name = field.alias\n            # check if field has serialization alias\n            if field.serialization_alias:\n                name = field.serialization_alias\n            # filter fields\n            if match and not name.startswith(match):\n                continue\n            lines[name] = f\"{field.description}\"\n            if verbose:\n                lines[name] += (\n                    f\"; default '{field.get_default()}', type '{str(field.annotation)}', \"\n                    f\"is required - {field.is_required()}\"\n                )\n    # check if model has pipe defined\n    if hasattr(model[\"model\"], \"PicleConfig\") and getattr(\n        model[\"model\"].PicleConfig, \"pipe\", None\n    ):\n        name = \"|\"\n        lines[name] = \"Execute pipe command\"\n    width = max((len(k) for k in lines), default=width)\n    # form help lines\n    help_msg = []\n    for k in sorted(lines.keys()):\n        padding = \" \" * (width - len(k)) + (\" \" * 4)\n        help_msg.append(f\" {k}{padding}{lines[k]}\")\n\n    if print_help:  # print help message\n        self.write(self.newline.join(help_msg))\n    else:\n        return help_msg, width\n</code></pre>"},{"location":"api_reference/#picle.App.process_help_command","title":"<code>picle.App.process_help_command(line: str) -&gt; None</code>","text":"<p>Process inline help triggered by '?' or '??' at the end of a command line.</p> <p>Parameters:</p> <ul> <li> <code>line</code>               (<code>str</code>)           \u2013            <p>input command line string ending with '?' or '??'.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def process_help_command(self, line: str) -&gt; None:\n    \"\"\"\n    Process inline help triggered by '?' or '??' at the end of a command line.\n\n    :param line: input command line string ending with '?' or '??'.\n    \"\"\"\n    verbose = line.endswith(\"??\")\n    try:\n        command_models = self.parse_command(line.rstrip(\"?\"), is_help=True)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        self.print_model_help([[model]], verbose=verbose, match=parameter)\n    except FieldKeyError as e:\n        model, parameter = e.args\n        self.write(\n            f\"Incorrect command, '{parameter}' not part of \"\n            f\"'{self._get_model_name(model)}' model fields\"\n        )\n    else:\n        self.print_model_help(command_models, verbose=verbose)\n</code></pre>"},{"location":"api_reference/#picle.App.write","title":"<code>picle.App.write(output: str) -&gt; None</code>","text":"<p>Method to write output to stdout</p> <p>Parameters:</p> <ul> <li> <code>output</code>               (<code>str</code>)           \u2013            <p>output to write to stdout</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def write(self, output: str) -&gt; None:\n    \"\"\"\n    Method to write output to stdout\n\n    :param output: output to write to stdout\n    \"\"\"\n    if self.use_rich and HAS_RICH:\n        RICHCONSOLE.print(output)\n    else:\n        if not isinstance(output, str):\n            output = str(output)\n        if not output.endswith(self.newline):\n            output += self.newline\n        self.stdout.write(output)\n</code></pre>"},{"location":"api_reference/#picle-build-in-models","title":"PICLE Build In Models","text":""},{"location":"api_reference/#picle.models.Filters","title":"<code>picle.models.Filters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Filters.filter_exclude","title":"<code>picle.models.Filters.filter_exclude(data: Any, exclude: Any = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Filter data line by line using provided pattern. Returns only lines that do not contain the requested <code>exclude</code> pattern.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>data to filter</p> </li> <li> <code>exclude</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>pattern to filter data</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef filter_exclude(data: Any, exclude: Any = None) -&gt; str:\n    \"\"\"\n    Filter data line by line using provided pattern. Returns\n    only lines that do not contain the requested ``exclude`` pattern.\n\n    :param data: data to filter\n    :param exclude: pattern to filter data\n    \"\"\"\n    exclude = str(exclude)\n    return \"\\n\".join(\n        [line for line in str(data).splitlines() if exclude not in line]\n    )\n</code></pre>"},{"location":"api_reference/#picle.models.Filters.filter_include","title":"<code>picle.models.Filters.filter_include(data: Any, include: Any = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Filter data line by line using provided pattern. Returns only lines that contain the requested <code>include</code> pattern.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>data to filter</p> </li> <li> <code>include</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>pattern to filter data</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef filter_include(data: Any, include: Any = None) -&gt; str:\n    \"\"\"\n    Filter data line by line using provided pattern. Returns\n    only lines that contain the requested ``include`` pattern.\n\n    :param data: data to filter\n    :param include: pattern to filter data\n    \"\"\"\n    include = str(include)\n    return \"\\n\".join([line for line in str(data).splitlines() if include in line])\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters","title":"<code>picle.models.Outputters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Outputters.outputter_json","title":"<code>picle.models.Outputters.outputter_json(data: Union[dict, list, bytes], indent: int = 4) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Function to pretty print JSON string using Rich library</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[dict, list, bytes]</code>)           \u2013            <p>any data to print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_json(data: Union[dict, list, bytes], indent: int = 4) -&gt; Any:\n    \"\"\"\n    Function to pretty print JSON string using Rich library\n\n    :param data: any data to print\n    \"\"\"\n    if isinstance(data, bytes):\n        data = data.decode(\"utf-8\")\n\n    if isinstance(data, str):\n        return data\n\n    # data should be a json string\n    try:\n        data = json.dumps(data, indent=indent, sort_keys=True)\n    except Exception as e:\n        print(\n            f\"ERROR: Failed to format data as JSON string:\\n{data}\\n\\nError: '{e}'\"\n        )\n\n    return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_kv","title":"<code>picle.models.Outputters.outputter_kv(data: dict) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Format a dictionary as a key-value output string.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>dictionary to format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>formatted key-value string.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_kv(data: dict) -&gt; str:\n    \"\"\"\n    Format a dictionary as a key-value output string.\n\n    :param data: dictionary to format.\n    :return: formatted key-value string.\n    \"\"\"\n    if isinstance(data, str):\n        return data\n    return \"\\n\".join([f\" {k}: {v}\" for k, v in data.items()])\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_nested","title":"<code>picle.models.Outputters.outputter_nested(data: Union[dict, list], initial_indent: int = 0, with_tables: bool = False, tabulate_kwargs: dict = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Recursively formats and prints nested data structures (dictionaries and lists) in a human-readable format.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[dict, list]</code>)           \u2013            <p>nested data structure to be formatted and printed.</p> </li> <li> <code>initial_indent</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>initial indentation level.</p> </li> <li> <code>with_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if True, will format flat lists as Tabulate tables.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_nested(\n    data: Union[dict, list],\n    initial_indent: int = 0,\n    with_tables: bool = False,\n    tabulate_kwargs: dict = None,\n) -&gt; str:\n    \"\"\"\n    Recursively formats and prints nested data structures (dictionaries and lists)\n    in a human-readable format.\n\n    :param data: nested data structure to be formatted and printed.\n    :param initial_indent: initial indentation level.\n    :param with_tables: if True, will format flat lists as Tabulate tables.\n    \"\"\"\n    tabulate_kwargs = tabulate_kwargs or {\"tablefmt\": \"simple\"}\n\n    def is_dictionary_list(data):\n        for item in data:\n            if not isinstance(item, Mapping):\n                return False\n            for i in item.values():\n                if isinstance(i, (list, tuple, Mapping)):\n                    return False\n        return True\n\n    def ustring(indent, msg, prefix=\"\", suffix=\"\"):\n        indent *= \" \"\n        fmt = \"{0}{1}{2}{3}\"\n        return fmt.format(indent, prefix, msg, suffix)\n\n    def nest(ret, indent, prefix, out):\n        if isinstance(ret, bytes):\n            try:\n                ret = ret.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                ret = str(ret)\n\n        if ret is None or ret is True or ret is False:\n            out.append(ustring(indent, ret, prefix=prefix))\n        elif isinstance(ret, Number):\n            out.append(ustring(indent, repr(ret), prefix=prefix))\n        elif isinstance(ret, str):\n            first_line = True\n            for line in ret.splitlines():\n                line_prefix = \" \" * len(prefix) if not first_line else prefix\n                out.append(ustring(indent, line, prefix=line_prefix))\n                first_line = False\n        elif isinstance(ret, (list, tuple)):\n            # make a text table if it is a flat list\n            if with_tables and is_dictionary_list(ret):\n                table = Outputters.outputter_tabulate_table(ret, **tabulate_kwargs)\n                nest(table, indent + 2, prefix, out)\n            else:\n                for ind in ret:\n                    if isinstance(ind, (list, tuple, Mapping)):\n                        out.append(ustring(indent, \"|_\"))\n                        prefix = \"\" if isinstance(ind, Mapping) else \"- \"\n                        nest(ind, indent + 2, prefix, out)\n                    else:\n                        nest(ind, indent, \"- \", out)\n        elif isinstance(ret, Mapping):\n            if indent:\n                out.append(ustring(indent, \"----------\"))\n\n            for key in ret.keys():\n                val = ret[key]\n                out.append(ustring(indent, key, suffix=\":\", prefix=prefix))\n                nest(val, indent + 4, \"\", out)\n\n        return out\n\n    # make sure data is sorted\n    try:\n        if isinstance(data, dict):\n            data = dict(sorted(data.items()))\n        elif isinstance(data, list):\n            data = list(sorted(data))\n    except Exception as e:\n        log.warning(f\"Nested outputter data sorting failed: '{e}'\")\n\n    lines = nest(data, initial_indent, \"\", [])\n    lines = \"\\n\".join(lines)\n\n    return lines\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_pprint","title":"<code>picle.models.Outputters.outputter_pprint(data: Any) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Pretty-print results using Python's <code>pprint</code> module.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to pretty-print.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>nicely formatted string representation.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_pprint(data: Any) -&gt; str:\n    \"\"\"\n    Pretty-print results using Python's ``pprint`` module.\n\n    :param data: any data to pretty-print.\n    :return: nicely formatted string representation.\n    \"\"\"\n    if isinstance(data, str):\n        return data\n    return pprint.pformat(data, indent=4)\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_markdown","title":"<code>picle.models.Outputters.outputter_rich_markdown(data: Any) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Function to print markdown output using Rich library</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_markdown(data: Any) -&gt; Any:\n    \"\"\"\n    Function to print markdown output using Rich library\n\n    :param data: any data to print\n    \"\"\"\n    if not isinstance(data, str):\n        data = str(data)\n\n    if HAS_RICH:\n        return Markdown(data)\n    else:\n        return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_table","title":"<code>picle.models.Outputters.outputter_rich_table(data: list[dict], headers: list = None, title: str = None, sortby: str = None) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Format a list of dictionaries as a Rich table.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>list[dict]</code>)           \u2013            <p>list of dictionaries to display.</p> </li> <li> <code>headers</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>column headers; defaults to the keys of the first row.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>optional table title.</p> </li> <li> <code>sortby</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>key name to sort rows by.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>a Rich <code>Table</code> object, or the original data if Rich is unavailable.</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_table(\n    data: list[dict], headers: list = None, title: str = None, sortby: str = None\n) -&gt; Any:\n    \"\"\"\n    Format a list of dictionaries as a Rich table.\n\n    :param data: list of dictionaries to display.\n    :param headers: column headers; defaults to the keys of the first row.\n    :param title: optional table title.\n    :param sortby: key name to sort rows by.\n    :return: a Rich ``Table`` object, or the original data if Rich is unavailable.\n    \"\"\"\n    if not HAS_RICH or not isinstance(data, list):\n        return data\n\n    if not data:\n        return data\n\n    headers = headers or list(data[0].keys())\n    table = RICHTABLE(title=title, box=False)\n\n    # add table columns\n    for h in headers:\n        table.add_column(h, justify=\"left\", no_wrap=True)\n\n    # sort the table\n    if sortby:\n        sorted_data = sorted(data, key=lambda d: d[sortby])\n    else:\n        sorted_data = data\n\n    # add table rows\n    for item in sorted_data:\n        cells = [str(item.get(h, \"\")) for h in headers]\n        table.add_row(*cells)\n\n    return table\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_save","title":"<code>picle.models.Outputters.outputter_save(data: Any, save: str) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Function to output data into a file</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_save(data: Any, save: str) -&gt; Any:\n    \"\"\"\n    Function to output data into a file\n\n    :param data: any data to print\n    \"\"\"\n    # create directories\n    abspath = os.path.abspath(save)\n    dirs = os.path.split(abspath)[0]\n    os.makedirs(dirs, exist_ok=True)\n\n    # save data to file\n    with open(save, \"w\") as f:\n        if isinstance(data, str):\n            f.write(data)\n        else:\n            f.write(str(data))\n\n    return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_tabulate_table","title":"<code>picle.models.Outputters.outputter_tabulate_table(data: list, headers_exclude: list = None, sortby: str = None, reverse: bool = False, tablefmt: str = 'grid', headers: list = None, showindex: bool = True, maxcolwidths: int = None) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Formats and outputs data as a text table.</p> <p>This function uses the <code>tabulate</code> library to format a list of dictionaries or lists of lists of dictionaries into a table with various styles and options for customization.</p> <p>Parameters:</p> <pre><code>data (list): A list of dictionaries or list of lists to be formatted into a table.\n    If it is list of lists, the function merges nested lists.\nheaders (list or str, optional): Specifies the table headers. Can be:\n\n    - A list of headers.\n    - A comma-separated string of headers.\n    - \"keys\" to use dictionary keys as headers.\n\nshowindex (bool, optional): If True, includes an index column in the table.\nheaders_exclude (list, optional): A list or comma-separated string of headers to exclude from the table.\nsortby (str, optional): The key name to sort the table by. If None, no sorting is applied.\nreverse (bool, optional): If True, reverses the sort order. Defaults to False.\n</code></pre> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_tabulate_table(\n    data: list,\n    headers_exclude: list = None,\n    sortby: str = None,\n    reverse: bool = False,\n    tablefmt: str = \"grid\",\n    headers: list = None,\n    showindex: bool = True,\n    maxcolwidths: int = None,\n) -&gt; Any:\n    \"\"\"\n    Formats and outputs data as a text table.\n\n    This function uses the `tabulate` library to format a list of dictionaries or\n    lists of lists of dictionaries into a table with various styles and options\n    for customization.\n\n    Parameters:\n\n        data (list): A list of dictionaries or list of lists to be formatted into a table.\n            If it is list of lists, the function merges nested lists.\n        headers (list or str, optional): Specifies the table headers. Can be:\n\n            - A list of headers.\n            - A comma-separated string of headers.\n            - \"keys\" to use dictionary keys as headers.\n\n        showindex (bool, optional): If True, includes an index column in the table.\n        headers_exclude (list, optional): A list or comma-separated string of headers to exclude from the table.\n        sortby (str, optional): The key name to sort the table by. If None, no sorting is applied.\n        reverse (bool, optional): If True, reverses the sort order. Defaults to False.\n    \"\"\"\n    if not HAS_TABULATE:\n        log.error(\n            \"PICLE Table outputter tabulate library import failed, install: pip install tabulate\"\n        )\n        return data\n    if not isinstance(data, list):\n        log.error(\"PICLE Table outputter data is not a list\")\n        return data\n\n    # transform headers to exclude argument\n    headers_exclude = headers_exclude or []\n    if isinstance(headers_exclude, str) and \",\" in headers_exclude:\n        headers_exclude = [i.strip() for i in headers_exclude.split(\",\")]\n\n    # form base tabulate arguments\n    if isinstance(headers, str):\n        headers = [i.strip() for i in headers.split(\",\")]\n    elif headers is None:\n        headers = \"keys\"\n\n    tabulate_kw = {\n        \"headers\": headers,\n        \"tablefmt\": tablefmt,\n        \"maxcolwidths\": maxcolwidths,\n    }\n\n    # form singe table out of list of lists\n    table_ = []\n    while data:\n        item = data.pop(0)\n        if isinstance(item, list):\n            table_.extend(item)\n        else:\n            table_.append(item)\n    data = table_\n\n    # sort results\n    if sortby:\n        data = sorted(\n            data,\n            reverse=reverse,\n            key=lambda item: str(item.get(sortby, \"\")),\n        )\n\n    # filter table headers if requested to do so\n    if headers_exclude:\n        data = [\n            {k: v for k, v in res.items() if k not in headers_exclude}\n            for res in data\n        ]\n\n    # transform data content to match headers\n    if isinstance(tabulate_kw[\"headers\"], list):\n        data = [[item.get(i, \"\") for i in tabulate_kw[\"headers\"]] for item in data]\n\n    # start index with 1 instead of 0\n    if showindex is True:\n        showindex = range(1, len(data) + 1)\n        tabulate_kw[\"showindex\"] = showindex\n\n    return tabulate_lib.tabulate(data, **tabulate_kw)\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_yaml","title":"<code>picle.models.Outputters.outputter_yaml(data: Union[dict, list, bytes], absolute_indent: int = 0, indent: int = 2) -&gt; Any</code>  <code>staticmethod</code>","text":"<p>Function to format structured data as YAML string</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[dict, list, bytes]</code>)           \u2013            <p>any data to print</p> </li> <li> <code>absolute_indent</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>indentation to prepend for entire output</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_yaml(\n    data: Union[dict, list, bytes], absolute_indent: int = 0, indent: int = 2\n) -&gt; Any:\n    \"\"\"\n    Function to format structured data as YAML string\n\n    :param data: any data to print\n    :param absolute_indent: indentation to prepend for entire output\n    \"\"\"\n    if isinstance(data, bytes):\n        data = data.decode(\"utf-8\")\n\n    if isinstance(data, str):\n        return data\n\n    # data should be a YAML string\n    try:\n        if HAS_YAML:\n            data = yaml.safe_dump(\n                data, default_flow_style=False, sort_keys=True, indent=indent\n            )\n            # add  indent\n            if absolute_indent:\n                data = \"\\n\".join(\n                    [f\"{' ' * absolute_indent}{i}\" for i in data.splitlines()]\n                )\n        else:\n            log.error(\n                \"PICLE YAML outputter yaml library import failed, install: pip install pyyaml\"\n            )\n    except Exception as e:\n        print(\n            f\"ERROR: Failed to format data as YAML string:\\n{data}\\n\\nError: '{e}'\"\n        )\n\n    return data\n</code></pre>"},{"location":"api_reference/#picle.models.PipeFunctionsModel","title":"<code>picle.models.PipeFunctionsModel</code>","text":"<p>               Bases: <code>Filters</code>, <code>Outputters</code></p> <p>Collection of common pipe functions to use in PICLE shell models</p>"},{"location":"api_reference/#picle.models.MAN","title":"<code>picle.models.MAN</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Manual and documentation related functions</p>"},{"location":"api_reference/#picle.models.MAN.print_model_json_schema","title":"<code>picle.models.MAN.print_model_json_schema(root_model, **kwargs) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Method to print model json schema for shell model specified by dot separated path e.g. model.shell.command</p> <p>Parameters:</p> <ul> <li> <code>root_model</code>           \u2013            <p>PICLE App root model to print json schema for</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef print_model_json_schema(root_model, **kwargs) -&gt; str:\n    \"\"\"\n    Method to print model json schema for shell model specified by dot separated path e.g. model.shell.command\n\n    :param root_model: PICLE App root model to print json schema for\n    \"\"\"\n\n    class MyGenerateJsonSchema(GenerateJsonSchema):\n        def handle_invalid_for_json_schema(\n            self, schema: core_schema.CoreSchema, error_info: str\n        ) -&gt; JsonSchemaValue:\n            raise PydanticOmit\n\n        def callable_schema(self, schema):\n            print(schema)\n            raise PydanticOmit\n\n        def render_warning_message(kind, detail: str) -&gt; None:\n            print(kind, detail)\n\n    path = kwargs[\"json_schema\"].split(\".\") if kwargs.get(\"json_schema\") else []\n    model = MAN._recurse_to_model(root_model, path=path)\n    return json.dumps(\n        model.model_json_schema(schema_generator=MyGenerateJsonSchema),\n        indent=4,\n        sort_keys=True,\n    )\n</code></pre>"},{"location":"api_reference/#picle.models.MAN.print_model_tree","title":"<code>picle.models.MAN.print_model_tree(root_model, **kwargs) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Method to print model tree for shell model specified by dot separated path e.g. model.shell.command</p> <p>Parameters:</p> <ul> <li> <code>root_model</code>           \u2013            <p>PICLE App root model to print tree for</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef print_model_tree(root_model, **kwargs) -&gt; None:\n    \"\"\"\n    Method to print model tree for shell model specified by dot separated path e.g. model.shell.command\n\n    :param root_model: PICLE App root model to print tree for\n    \"\"\"\n    if HAS_RICH:\n        path = kwargs[\"tree\"].split(\".\") if kwargs.get(\"tree\") else []\n        rich_tree = RICHTREE(\"[bold]root[/bold]\")\n        RICHCONSOLE.print(\n            MAN._construct_model_tree(\n                model=root_model.model_construct(), tree=rich_tree, path=path\n            )\n        )\n    else:\n        log.error(\n            \"PICLE model tree outputter requires Rich library, install: pip install rich\"\n        )\n</code></pre>"},{"location":"changelog/","title":"0.9.4","text":""},{"location":"changelog/#changes","title":"CHANGES","text":"<ol> <li>Dependencies updates to loosen them up</li> <li>Adding type hints throughout and updating doc strings</li> <li>Fixed pydantic warnings about model_fields access and about using extra arguments on fields</li> </ol>"},{"location":"changelog/#features","title":"FEATURES","text":"<ol> <li>Added ConfigModel model to picle to help with maintaininng configuration files using Picle interactive shell.</li> </ol>"},{"location":"changelog/#bugs","title":"BUGS","text":"<ol> <li>init ~L97 -PicleConfig accessed without hasattr guard \u2014 crash for models without it</li> <li>do_help ~L855 - Multi-word help silently discarded \u2014 never printed</li> <li>do_help ~L857 - Unhandled FieldLooseMatchOnly/FieldKeyError exceptions</li> <li>print_model_help - Medium    width not computed for all lines keys \u2014 misaligned output</li> <li>default ~L1004 - Partial alias match reports empty completions list</li> <li>do_exit ~L872 - Missing PicleConfig guard on prompt access</li> <li>do_top ~L883 - Same missing guard</li> </ol>"},{"location":"changelog/#093","title":"0.9.3","text":""},{"location":"changelog/#changes_1","title":"CHANGES","text":"<ol> <li>Improving outputter models handling</li> </ol>"},{"location":"changelog/#092","title":"0.9.2","text":""},{"location":"changelog/#changes_2","title":"CHANGES","text":"<ol> <li>Improved value conversion logic to not convert values to integers or bool etc if field annotation is <code>str</code> or <code>StrictStr</code></li> <li>Updated <code>pyproject.toml</code> file with dependency version for PyYAML and Tabulate modules</li> </ol>"},{"location":"changelog/#091","title":"0.9.1","text":""},{"location":"changelog/#features_1","title":"FEATURES","text":"<ol> <li>Extending nested outputter with capability to include tables within nested output if data is a list of dictionaries</li> </ol>"},{"location":"changelog/#090","title":"0.9.0","text":""},{"location":"changelog/#changes_3","title":"CHANGES","text":"<ol> <li>Removed support for using <code>Callable</code> annotation for calling model method</li> <li>Removed formatters from built in models, instead need to use outputter</li> <li>Improved pipe functions handling logic </li> <li>Rich is now a default outputter, can be disabled using <code>use_rich</code> config parameter in the root's model PicleConfig </li> </ol>"},{"location":"changelog/#features_2","title":"FEATURES","text":"<ol> <li>Added Tabulate table outputter</li> <li>Added <code>save</code> outputter to save results into a file</li> <li>Added support for pipe attribute to reference <code>path.to.pipemodel</code> Python import string</li> </ol>"}]}
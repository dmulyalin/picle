{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#picle-python-interactive-command-line-shells","title":"PICLE - Python Interactive Command Line Shells","text":"<p>PICLE is a module to construct interactive command line shell applications.</p> <p>PICLE build on top of Python standard library CMD module and uses Pydantic models to construct shell environments.</p> <p>If the <code>readline</code> module is loaded (pyreadline3), input will automatically inherit bash-like history-list editing (e.g. Control-P scrolls back to the last command, Control-N forward to the next one, Control-F moves the cursor to the right non-destructively, Control-B moves the cursor to the left non-destructively, etc.).</p>"},{"location":"#installation","title":"Installation","text":"<p>Install PICLE from PyPI using pip</p> <pre><code>pip install picle\n</code></pre>"},{"location":"#comparison-with-other-projects","title":"Comparison With Other Projects","text":"<p>python-nubia by Facebook - unfortunately this project no longer maintained, it also provides no integration with Pydantic.</p> <p>python-fire, click or argparse - all these libraries are great for building command line tools, but they provide no support for interactive shell or input validation supported by Pydantic.</p> <p>prompt-toolkit or textual - those are extremely good libraries for building Terminal User Interface (TUI) applications but they provide no support for interactive shell and Pydantic validation of input.</p>"},{"location":"Getting%20Started/","title":"Getting Started","text":""},{"location":"Getting%20Started/#introducing-picle","title":"Introducing PICLE","text":"<p>Command-line interface (CLI) is the software interface used to interact with the system. From CLI you can run commands and receive output.</p> <p>The command-line interface usually includes lots of shortcuts and commands to get help, auto completion, argument choices and validation of input.</p> <p>PICLE creates structures of shell modes hierarchies, as illustrated in Figure 1. The hierarchy of each mode is made up of cascading branches of related commands and their functions.</p> <pre><code>Root\n   |-command -&gt; Model\n     |-command -&gt; Field\n     |-command -&gt; Field\n     |-command -&gt; Field\n     |-RUN Function\n   |-command -&gt; Function\n   |-command -&gt; Model\n     |-Shell\n       |-command -&gt; Field\n       |-command -&gt; Model\n         |-command -&gt; Field\n         |-RUN Function\n</code></pre> <p>Figure 1. Sample shells hierarchy.</p> <p>Each shell has its own prompt and a set of commands.</p> <p>Commands parsed sequentially in the order they are inputted on the command line.</p> <p>Each command can point to one of:</p> <ul> <li>Pydantic model with or without shell</li> <li>A Pydantic model field with values to collect</li> <li>A function to run</li> </ul> <p>Each model may have a <code>RUN</code> function defined, this function executed with collected field values.</p>"},{"location":"Getting%20Started/#sample-application","title":"Sample Application","text":"<p>PICLE uses Pydantic models to construct interactive shells and their commands. For example, to create interactive shell that has this structure:</p> <pre><code>Root\n   |-show -&gt; model_show\n     |-version -&gt; Function - output software version\n     |-clock -&gt; Function - display system time\n</code></pre> <p>Can use code below:</p> <pre><code>import time\nfrom picle import App\nfrom typing import Callable\nfrom pydantic import BaseModel, Field\n\n\nclass model_show(BaseModel):\n    version: Callable = Field(\"show_version\", description=\"Show software version\")\n    clock: Callable = Field(\"show_clock\", description=\"Show current clock\")\n\n    @staticmethod\n    def show_version():\n        return \"0.1.0\"\n\n    @staticmethod\n    def show_clock():\n        return time.ctime()\n\n\nclass Root(BaseModel):\n    show: model_show = Field(None, description=\"Show commands\")\n\n    class PicleConfig:\n        prompt = \"picle#\"\n        intro = \"PICLE Sample app\"\n\n\nif __name__ == \"__main__\":\n    shell = App(Root)\n    shell.start()\n</code></pre> <p>Each Pydantic model can have <code>PicleConfig</code> subclass defined listing model configuration.</p> <p><code>Root -&gt; show</code> model field refers to <code>model_show</code> Pydantic model which has two fields <code>version</code> and <code>clock</code> each referring to callable function which is executed when user hits ENTER on the command line.</p> <p>Run above code with <code>python myshellfile.py</code> command and interact with the shell:</p> <p></p>"},{"location":"api_reference/","title":"PICLE APIs Reference","text":""},{"location":"api_reference/#picleconfig","title":"PicleConfig","text":"<p>Each Pydantic model can have <code>PicleConfig</code> subclass defined with model configuration parameters:</p> <ul> <li><code>ruler</code> - The character used to draw separator lines under the help-message headers. If empty, no ruler line is drawn, defaults is empty</li> <li><code>intro</code> - A string to issue as an intro or banner</li> <li><code>prompt</code> - command line shell prompt</li> <li><code>newline</code> - newline character to use while printing output, default is <code>\\r\\n</code></li> <li><code>completekey</code> - is the <code>readline</code> name of a completion key, defaults to <code>tab</code></li> <li><code>pipe</code> - reference to Pydantic model class to use with <code>|</code> (pipe) to process the     results with various functions, special value <code>pipe = \"self\"</code> instruct to use     current model for piping results through.</li> <li><code>processors</code> - list of functions to run results of <code>first command</code> through one by one</li> <li><code>outputter</code> - function to output results, by default results written to stdout</li> <li><code>outputter_kwargs</code> - dictionary containing any additional argument to use with outputter</li> </ul> <p>Sample <code>PicleConfig</code> definition:</p> <pre><code>from picle.models import PipeFunctionsModel, Formatters, Outputters\n\nclass ShellModel(BaseModel):\n    \"\"\" define command attributes here \"\"\"\n    &lt;...&gt;\n\n    class PicleConfig:\n        prompt = \"picle#\"\n        ruler = \"\"\n        intro = \"PICLE Sample app\"\n        newline = \"\\r\\n\"\n        completekey = \"tab\"\n        pipe = PipeFunctionsModel\n        processors = [Formatters.formatter_json]\n        outputter = Outputters.outputter_rich_print\n        outputter_kwargs = {\"any\": \"extra_argument\"}\n</code></pre>"},{"location":"api_reference/#field-json_schema_extra","title":"Field json_schema_extra","text":"<p>PICLE supports reading additional parameters from model Field's <code>json_schema_extra</code> definition to control PICLE behavior.</p> <p><code>json_schema_extra</code> PICLE parameters:</p> <ul> <li><code>function</code> - refers to <code>@staticmethod</code> of the model to call with command arguments</li> <li><code>presence</code> - command argument set to <code>presence</code> value if command given</li> <li><code>processors</code> - list of functions to run results of each command through one by one</li> <li><code>outputter</code> - function to output results, by default results written to     stdout. Field's <code>outputter</code> overrides PicleConfig's <code>outputter</code></li> <li><code>outputter_kwargs</code> - dictionary containing any additional argument to use with outputter</li> <li><code>multiline</code> - True/False, indicates if multi line input mode is enabled for this field</li> <li><code>root_model</code> - True/False, if True reference to PICLE App's root model passed on to     the <code>run</code> method or to the <code>function</code> inside <code>root_model</code> argument</li> <li><code>picle_app</code> - True/False, if True reference to PICLE App passed on to the <code>run</code>     method or to the <code>function</code> inside <code>picle_app</code> argument, useful if need to modify     PICLE App in a runtime, for example mount or remove models</li> </ul>"},{"location":"api_reference/#field-processors","title":"Field processors","text":"<p>Processors allow to pass command execution results through a list of arbitrary functions. Results returned by processor function passed on as input to next processor function in the list and so on.</p> <p>In example below results returned by <code>produce_structured_data</code> function passed through pprint formatter <code>Formatters.formatter_pprint</code> function to produce pretty formatted string.</p> <pre><code>from picle.models import Formatters\n\nclass model_show(BaseModel):\n    data_pprint: Callable = Field(\n        \"produce_structured_data\",\n        description=\"Show data using pprint formatter\",\n        json_schema_extra={\n            \"processors\": [\n                    Formatters.formatter_pprint\n                ]\n            }\n    )\n\n    @staticmethod\n    def produce_structured_data():\n        return {\"some\": {\"dictionary\": {\"data\": None}}, \"more\": {\"dictionary\": [\"data\"]}, \"even\": {\"more\": {\"dictionary\": \"data\"}}}\n</code></pre>"},{"location":"api_reference/#multi-line-input","title":"Multi Line Input","text":"<p>Multi line input allows to read multiple lines of text into field value if json_schema_extra <code>multiline</code> argument is set to <code>True</code>. To use it need to specify <code>input</code> as a field value on the command line, that will trigger multi line input collection when hit return:</p> <p>Sample model that has multi line input enabled:</p> <pre><code>class model_TestMultilineInput(BaseModel):\n    data: StrictStr = Field(\n        None,\n        description=\"Multi line string\",\n        json_schema_extra={\"multiline\": True}\n    )\n    arg: Any = Field(None, description=\"Some field\")\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n</code></pre> <p>This is how help will look like for <code>data</code> field:</p> <pre><code>picle#test_multiline_input data ?\n &lt;'data' value&gt;    Multi line string\n input             Collect value using multi line input mode\npicle#\n</code></pre> <p>Tab completion for <code>input</code> value also works. On hitting <code>enter</code>, multi line input mode will be invoked:</p> <pre><code>picle#test_multiline_input data input arg foo\nEnter lines and hit Ctrl+D to finish multi line input\nI'am\nMulti Line\nInput\n&lt;ctrl+D hit&gt;\n</code></pre>"},{"location":"api_reference/#result-specific-outputters","title":"Result Specific Outputters","text":"<p>Sometimes having outputter defined per model is not enough and depending on produced result different outputter need to be used, in that case result specific outputter can be provided in return to <code>run</code> function call by returning a tuple of <code>(result, outputter function, outputter kwargs,)</code>, where <code>outputter kwargs</code> is optional.</p> <p>Example:</p> <pre><code>from picle.models import Outputters\n\nclass model_ResultSpecificOutputter(BaseModel):\n    data: StrictStr = Field(None, description=\"Multi line string\")\n    arg: Any = Field(None, description=\"Some field\")\n\n    class PicleConfig:\n        outputter = Outputters.outputter_rich_print\n        outputter_kwargs = {\"any\": \"extra_argument\"}\n\n    @staticmethod\n    def run(**kwargs):\n        if kwargs.get(\"args\") == \"json\":\n            return kwargs[\"data\"], Outputters.outputter_rich_json, {}\n        elif kwargs.get(\"args\") == \"table\":\n            return kwargs[\"data\"], Outputters.outputter_rich_table\n        else:\n            return kwargs\n</code></pre> <p>In addition to <code>PicleConfig</code> outputter, depending on arguments provided  <code>run</code> function returns outputter function to use to output the result with optional <code>outputter_kwargs</code> as a third argument. By default, if return result is not a tuple, outputter specified in <code>PicleConfig</code> is used.</p> <p>Note</p> <p>Result specific outputters supported starting with PICLE version 0.7.0</p>"},{"location":"api_reference/#mounting-models-at-a-runtime","title":"Mounting Models at a Runtime","text":"<p>Sometimes it is needed to dynamically add new shell commands to the app, for that PICLE <code>App</code> has <code>model_mount</code> and <code>model_remove</code> methods.</p> <p>Example how to mount Pydantic model to PICLE App at given path in a runtime.</p> <pre><code>from picle import App\nfrom pydantic import BaseModel, StrictStr\n\nclass my_mount_model(BaseModel):\n    param: StrictStr = Field(None, description=\"Param string\")\n\n    @staticmethod\n    def run(**kwargs):\n        return kwargs\n\n# create PICLE Root model\nclass Root(BaseModel):\n    command: StrictStr = Field(None, description=\"Some command string\")\n\n# instantiate PICLE App shell\nshell = App(Root)\n\n# mount model\nshell.model_mount(my_mount_model, [\"another_command\"])\n\n# remove model\nshell.model_remove([\"another_command\"])\n\nshell.close()\n</code></pre>"},{"location":"api_reference/#picle-app","title":"PICLE App","text":""},{"location":"api_reference/#picle.App","title":"<code>picle.App(root, stdin=None, stdout=None)</code>","text":"<p>               Bases: <code>Cmd</code></p> <p>PICLE App class to construct shell.</p> <p>Parameters:</p> <ul> <li> <code>root</code>           \u2013            <p>Root/Top Pydantic model</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def __init__(self, root, stdin=None, stdout=None):\n    self.root = root\n    self.shell = self.root.model_construct()\n    self.shell_defaults = {}\n    self.shells = [self.shell]\n\n    # extract configuration from shell model\n    if hasattr(self.shell, \"PicleConfig\"):\n        self.ruler = getattr(self.shell.PicleConfig, \"ruler\", self.ruler)\n        self.intro = getattr(self.shell.PicleConfig, \"intro\", self.intro)\n        self.prompt = getattr(self.shell.PicleConfig, \"prompt\", self.prompt)\n        self.newline = getattr(self.shell.PicleConfig, \"newline\", self.newline)\n        self.completekey = getattr(\n            self.shell.PicleConfig, \"completekey\", self.completekey\n        )\n\n    # mount override methods\n    if hasattr(self.shell.PicleConfig, \"methods_override\"):\n        for (\n            method_name,\n            override,\n        ) in self.shell.PicleConfig.methods_override.items():\n            setattr(self, method_name, getattr(self.shell, override))\n\n    # mount models\n    self.model_mount(MAN, [\"man\"], \"Manual/documentation functions\")\n\n    super(App, self).__init__(stdin=stdin, stdout=stdout)\n</code></pre>"},{"location":"api_reference/#picle.App.completedefault","title":"<code>picle.App.completedefault(text, line, begidx, endidx)</code>","text":"<p>This method called for every  command parameter on complete key hit except for the very first one.</p> Source code in <code>picle\\picle.py</code> <pre><code>def completedefault(self, text, line, begidx, endidx):\n    \"\"\"\n    This method called for every  command parameter on\n    complete key hit except for the very first one.\n    \"\"\"\n    fieldnames = []\n    try:\n        command_models = self.parse_command(line, is_help=True)\n        last_model = command_models[-1][-1][\"model\"]\n        # check if last model has fields collected\n        if command_models[-1][-1][\"fields\"]:\n            last_field_name = command_models[-1][-1][\"fields\"][-1][\"name\"]\n            last_field = last_model.model_fields[last_field_name]\n            last_field_value = command_models[-1][-1][\"fields\"][-1][\"values\"]\n            fparam = self._get_field_params(last_field)\n            if isinstance(last_field_value, list):\n                last_field_value = last_field_value[-1]\n            elif last_field_value == ...:\n                last_field_value = \"\"\n            # check if need to extract enum values\n            if isinstance(last_field.annotation, enum.EnumMeta):\n                fieldnames = [\n                    i.value\n                    for i in last_field.annotation\n                    if i.value.startswith(last_field_value)\n                ]\n            # check if model has method to source field choices\n            elif hasattr(last_model, f\"source_{last_field_name}\"):\n                fieldnames = getattr(last_model, f\"source_{last_field_name}\")()\n                fieldnames = [\n                    i for i in fieldnames if i.startswith(last_field_value)\n                ]\n            # auto complete 'input' for multi-line input mode\n            elif fparam.get(\"multiline\") is True:\n                if (\n                    \"input\".startswith(last_field_value)\n                    and last_field_value != \"input\"\n                ):\n                    fieldnames = [\"input\"]\n        # return a list of all model fields\n        else:\n            for name, f in last_model.model_fields.items():\n                if f.alias:\n                    fieldnames.append(f.alias)\n                else:\n                    fieldnames.append(name)\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        for name, f in model[\"model\"].model_fields.items():\n            # skip fields with already collected values from complete prompt\n            if any(\n                collected_field[\"name\"] == name\n                for collected_field in model[\"fields\"]\n                if collected_field[\"values\"] is not ...\n            ):\n                continue\n            elif f.alias and f.alias.startswith(parameter):\n                fieldnames.append(f.alias)\n            elif name.startswith(parameter):\n                fieldnames.append(name)\n    except FieldKeyError:\n        pass\n    except:\n        tb = traceback.format_exc()\n        self.write(tb)\n\n    return sorted(fieldnames)\n</code></pre>"},{"location":"api_reference/#picle.App.completenames","title":"<code>picle.App.completenames(text, line, begidx, endidx)</code>","text":"<p>This method only called for the very first command parameter on complete key hit.</p> Source code in <code>picle\\picle.py</code> <pre><code>def completenames(self, text, line, begidx, endidx):\n    \"\"\"\n    This method only called for the very first command parameter on\n    complete key hit.\n    \"\"\"\n    fieldnames = []\n    # collect global methods\n    for method_name in dir(self):\n        if method_name.startswith(\"do_\"):\n            name = method_name.replace(\"do_\", \"\")\n            if name.startswith(line):\n                fieldnames.append(name)\n    # collect model arguments\n    try:\n        command_models = self.parse_command(line, is_help=True)\n        fieldnames.extend(command_models[-1][-1][\"model\"].model_fields)\n    # collect arguments that startswith last parameter\n    except FieldLooseMatchOnly as e:\n        model, parameter = e.args\n        for name, f in model[\"model\"].model_fields.items():\n            if f.alias and f.alias.startswith(parameter):\n                fieldnames.append(f.alias)\n            elif name.startswith(parameter):\n                fieldnames.append(name)\n    # raised if no model fields matched last parameter\n    except FieldKeyError as e:\n        log.debug(f\"No model fields matched last parameter - {e}\")\n        pass\n    return sorted(fieldnames)\n</code></pre>"},{"location":"api_reference/#picle.App.default","title":"<code>picle.App.default(line: str)</code>","text":"<p>Method called if no do_xyz methods found</p> Source code in <code>picle\\picle.py</code> <pre><code>@run_print_exception\ndef default(self, line: str):\n    \"\"\"Method called if no do_xyz methods found\"\"\"\n    ret = False\n    outputter = None\n\n    if line.strip().endswith(\"?\"):\n        try:\n            command_models = self.parse_command(\n                line.strip().rstrip(\"?\"), is_help=True\n            )\n        except FieldLooseMatchOnly as e:\n            model, parameter = e.args\n            self.print_model_help(\n                [[model]],\n                verbose=True if line.strip().endswith(\"??\") else False,\n                match=parameter,\n            )\n        except FieldKeyError as e:\n            model, parameter = e.args\n            model_name = (\n                model[\"model\"].__name__\n                if hasattr(model[\"model\"], \"__name__\")\n                else model[\"model\"].__repr_name__()\n            )\n            self.write(\n                f\"Incorrect command, '{parameter}' not part of '{model_name}' model fields\"\n            )\n        else:\n            self.print_model_help(\n                command_models,\n                verbose=True if line.strip().endswith(\"??\") else False,\n            )\n    else:\n        try:\n            command_models = self.parse_command(line, collect_multiline=True)\n        except FieldLooseMatchOnly as e:\n            model, parameter = e.args\n            # filter fields to return message for\n            fields = [\n                f.alias or name\n                for name, f in model[\"model\"].model_fields.items()\n                if name.startswith(parameter)\n            ]\n            self.write(\n                f\"Incomplete command, possible completions: \" f\"{', '.join(fields)}\"\n            )\n        except FieldKeyError as e:\n            model, parameter = e.args\n            model_name = (\n                model[\"model\"].__name__\n                if hasattr(model[\"model\"], \"__name__\")\n                else model[\"model\"].__repr_name__()\n            )\n            self.write(\n                f\"Incorrect command, '{parameter}' not part of '{model_name}' model fields\"\n            )\n        except ValidationError as e:\n            self.write(e)\n        else:\n            # go over collected commands separated by pipe\n            for index, command in enumerate(command_models):\n                # collect arguments\n                command_arguments = {\n                    f[\"name\"]: f[\"values\"]\n                    for model in command\n                    for f in model[\"fields\"]\n                    if f[\"values\"] is not ...\n                }\n                # collect command defaults\n                command_defaults = {}\n                for model in command:\n                    command_defaults.update(model.get(\"defaults\", {}))\n                model = command[-1][\"model\"]\n                # check if model has subshell\n                if (\n                    not command_arguments\n                    and hasattr(model, \"PicleConfig\")\n                    and getattr(model.PicleConfig, \"subshell\", None) is True\n                ):\n                    # collect parent shells and defaults\n                    for item in command[:-1]:\n                        m = item[\"model\"]\n                        self.defaults_update(m)  # store shell defaults\n                        if (\n                            hasattr(m, \"PicleConfig\")\n                            and getattr(m.PicleConfig, \"subshell\", None) is True\n                        ):\n                            if m not in self.shells:\n                                self.shells.append(m)\n                    # update prompt value\n                    self.prompt = getattr(model.PicleConfig, \"prompt\", self.prompt)\n                    self.shell = model\n                    self.shells.append(self.shell)\n                # run model \"run\" function if it exits\n                elif hasattr(model, \"run\"):\n                    # validate command argument values\n                    self._validate_values(command)\n                    # call first command using collected arguments only\n                    if index == 0:\n                        kw = {\n                            **self.shell_defaults,\n                            **command_defaults,\n                            **command_arguments,\n                        }\n                        ret = model.run(**kw)\n                    # pipe results through subsequent commands\n                    else:\n                        kw = {\n                            **command_defaults,\n                            **command_arguments,\n                        }\n                        ret = model.run(ret, **kw)\n                    # run processors from PicleConfig if any for first command only\n                    if index == 0:\n                        if hasattr(model, \"PicleConfig\") and hasattr(\n                            model.PicleConfig, \"processors\"\n                        ):\n                            for processor in model.PicleConfig.processors:\n                                if callable(processor):\n                                    ret = processor(ret)\n                    # extract outputter from PicleConfig\n                    if index == 0:\n                        # check if outputter returned together with results\n                        if isinstance(ret, tuple):\n                            if len(ret) == 2:\n                                ret, outputter = ret\n                                outputter_kwargs = {}\n                            elif len(ret) == 3:\n                                ret, outputter, outputter_kwargs = ret\n                        elif hasattr(model, \"PicleConfig\") and hasattr(\n                            model.PicleConfig, \"outputter\"\n                        ):\n                            outputter = model.PicleConfig.outputter\n                            outputter_kwargs = getattr(\n                                model.PicleConfig, \"outputter_kwargs\", {}\n                            )\n                # run command using Callable or json_schema_extra[\"function\"]\n                elif command[-1][\"fields\"]:\n                    # validate command argument values\n                    self._validate_values(command)\n                    # extract last field\n                    last_field_name = command[-1][\"fields\"][-1][\"name\"]\n                    last_field = model.model_fields[last_field_name]\n                    json_schema_extra = (\n                        getattr(last_field, \"json_schema_extra\") or {}\n                    )\n                    # check if last field refers to callable e.g. function\n                    if last_field.annotation is Callable:\n                        method_name = last_field.get_default()\n                        if method_name and hasattr(model, method_name):\n                            # call first command using collected arguments only\n                            if index == 0:\n                                kw = {\n                                    **self.shell_defaults,\n                                    **command_defaults,\n                                    **command_arguments,\n                                }\n                                # check if need to give root model as an argument\n                                if json_schema_extra.get(\"root_model\"):\n                                    kw[\"root_model\"] = self.root\n                                # check if need to give PICLE App as an argument\n                                if json_schema_extra.get(\"picle_app\"):\n                                    kw[\"picle_app\"] = self\n                                ret = getattr(model, method_name)(**kw)\n                            # pipe results through subsequent commands\n                            else:\n                                kw = {\n                                    **command_defaults,\n                                    **command_arguments,\n                                }\n                                ret = getattr(model, method_name)(ret, **kw)\n                        else:\n                            self.write(\n                                f\"Model '{model.__name__}' has no '{method_name}' \"\n                                f\"method defined for '{last_field_name}' Callable field\"\n                            )\n                    # check if last field has `function` parameter defined\n                    elif json_schema_extra.get(\"function\"):\n                        method_name = json_schema_extra[\"function\"]\n                        if hasattr(model, method_name):\n                            # call first command using collected arguments only\n                            if index == 0:\n                                kw = {\n                                    **self.shell_defaults,\n                                    **command_defaults,\n                                    **command_arguments,\n                                }\n                                # check if need to give root model as an argument\n                                if json_schema_extra.get(\"root_model\"):\n                                    kw[\"root_model\"] = self.root\n                                # check if need to give PICLE App as an argument\n                                if json_schema_extra.get(\"picle_app\"):\n                                    kw[\"picle_app\"] = self\n                                ret = getattr(model, method_name)(**kw)\n                            # pipe results through subsequent commands\n                            else:\n                                kw = {\n                                    **command_defaults,\n                                    **command_arguments,\n                                }\n                                ret = getattr(model, method_name)(ret, **kw)\n                        else:\n                            self.write(\n                                f\"Model '{model.__name__}' has no '{method_name}' \"\n                                f\"method defined for '{last_field_name}' function\"\n                            )\n                    else:\n                        self.write(\n                            f\"Model '{model.__name__}' has no 'run' method defined\"\n                        )\n                    # use processors from Field definition if any\n                    if json_schema_extra.get(\"processors\"):\n                        for processor in json_schema_extra[\"processors\"]:\n                            if callable(processor):\n                                ret = processor(ret)\n                    # run processors from PicleConfig if any for first command only\n                    if index == 0:\n                        if hasattr(model, \"PicleConfig\") and hasattr(\n                            model.PicleConfig, \"processors\"\n                        ):\n                            for processor in model.PicleConfig.processors:\n                                if callable(processor):\n                                    ret = processor(ret)\n                    # extract outputter from first command\n                    if index == 0:\n                        # check if outputter returned together with results\n                        if isinstance(ret, tuple):\n                            if len(ret) == 2:\n                                ret, outputter = ret\n                                outputter_kwargs = {}\n                            elif len(ret) == 3:\n                                ret, outputter, outputter_kwargs = ret\n                        # use outputter from Field definition\n                        elif json_schema_extra.get(\"outputter\"):\n                            outputter = json_schema_extra[\"outputter\"]\n                            outputter_kwargs = json_schema_extra.get(\n                                \"outputter_kwargs\", {}\n                            )\n                        # use PicleConfig outputter\n                        elif hasattr(model, \"PicleConfig\") and hasattr(\n                            model.PicleConfig, \"outputter\"\n                        ):\n                            outputter = model.PicleConfig.outputter\n                            outputter_kwargs = getattr(\n                                model.PicleConfig, \"outputter_kwargs\", {}\n                            )\n                else:\n                    self.defaults_pop(model)\n                    ret = f\"Incorrect command, provide more arguments for '{model}' model\"\n                    break\n\n    # returning True will end the shell - exit\n    if ret is True:\n        return True\n\n    if ret:\n        # use specified outputter to output results\n        if callable(outputter):\n            outputter(ret, **outputter_kwargs)\n        # write to stdout by default\n        else:\n            self.write(ret)\n</code></pre>"},{"location":"api_reference/#picle.App.do_cls","title":"<code>picle.App.do_cls(arg)</code>","text":"<p>Clear shell Screen</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_cls(self, arg):\n    \"\"\"Clear shell Screen\"\"\"\n    if \"?\" in arg:\n        self.write(\" cls    Clear shell Screen\")\n    else:\n        if \"LINUX\" in platform.system().upper():\n            os.system(\"clear\")\n        elif \"WINDOWS\" in platform.system().upper():\n            os.system(\"cls\")\n</code></pre>"},{"location":"api_reference/#picle.App.do_end","title":"<code>picle.App.do_end(arg)</code>","text":"<p>Exit application</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_end(self, arg):\n    \"\"\"Exit application\"\"\"\n    if \"?\" in arg:\n        self.write(\" end    Exit application\")\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/#picle.App.do_exit","title":"<code>picle.App.do_exit(arg)</code>","text":"<p>Exit current shell</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_exit(self, arg):\n    \"\"\"Exit current shell\"\"\"\n    if \"?\" in arg:\n        self.write(\" exit    Exit current shell\")\n    else:\n        # delete defaults for closing shell\n        self.defaults_pop(self.shells[-1])\n        _ = self.shells.pop(-1)\n        if self.shells:\n            self.shell = self.shells[-1]\n            self.prompt = self.shell.PicleConfig.prompt\n            if len(self.shells) == 1:  # check if reached top shell\n                self.defaults_set(self.shell)\n        else:\n            return True\n</code></pre>"},{"location":"api_reference/#picle.App.do_help","title":"<code>picle.App.do_help(arg)</code>","text":"<p>Print help message</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_help(self, arg):\n    \"\"\"Print help message\"\"\"\n    command_models = self.parse_command(arg.strip(\"?\"), is_help=True)\n    help_msg, width = self.print_model_help(\n        command_models,\n        verbose=True if arg.strip().endswith(\"?\") else False,\n        print_help=False,\n    )\n    # print help for global top commands\n    if len(arg.strip().split(\" \")) == 1:\n        lines = {}  # dict of {cmd: cmd_help}\n        for method_name in dir(self):\n            if method_name.startswith(\"do_\"):\n                name = method_name.replace(\"do_\", \"\")\n                lines[name] = getattr(self, method_name).__doc__\n                width = max(width, len(name))\n        # form help lines\n        if lines:\n            for k, v in lines.items():\n                padding = \" \" * (width - len(k)) + (\" \" * 4)\n                help_msg.append(f\" {k}{padding}{v}\")\n            # print help message\n            self.write(self.newline.join(help_msg))\n</code></pre>"},{"location":"api_reference/#picle.App.do_pwd","title":"<code>picle.App.do_pwd(arg)</code>","text":"<p>Print current shell path</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_pwd(self, arg):\n    \"\"\"Print current shell path\"\"\"\n    if \"?\" in arg:\n        self.write(\" pwd    Print current shell path\")\n    else:\n        path = [\"Root\"]\n        for shell in self.shells[1:]:\n            path.append(shell.__name__)\n        self.write(\"-&gt;\".join(path))\n</code></pre>"},{"location":"api_reference/#picle.App.do_top","title":"<code>picle.App.do_top(arg)</code>","text":"<p>Exit to top shell</p> Source code in <code>picle\\picle.py</code> <pre><code>def do_top(self, arg):\n    \"\"\"Exit to top shell\"\"\"\n    if \"?\" in arg:\n        self.write(\" top    Exit to top shell\")\n    else:\n        self.shell = self.shells[0]\n        self.prompt = self.shell.PicleConfig.prompt\n        while self.shells:\n            _ = self.shells.pop()\n        self.shells.append(self.shell)\n        # set shell defaults\n        self.defaults_set(self.shell)\n</code></pre>"},{"location":"api_reference/#picle.App.emptyline","title":"<code>picle.App.emptyline() -&gt; None</code>","text":"<p>Override empty line method to not run last command</p> Source code in <code>picle\\picle.py</code> <pre><code>def emptyline(self) -&gt; None:\n    \"\"\"Override empty line method to not run last command\"\"\"\n    return None\n</code></pre>"},{"location":"api_reference/#picle.App.model_mount","title":"<code>picle.App.model_mount(model: ModelMetaclass, path: Union[str, list[str]], description: str = None, default=None, **kwargs: dict) -&gt; None</code>","text":"<p>Method to mount pydantic model at provided path in relation to the root model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>ModelMetaclass</code>)           \u2013            <p>Pydantic model to mount.</p> </li> <li> <code>path</code>               (<code>Union[str, list[str]]</code>)           \u2013            <p>List of path segments to mount the model.</p> </li> <li> <code>description</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Description of the model.</p> </li> <li> <code>default</code>           \u2013            <p>Default value for the model.</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the FieldInfo.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def model_mount(\n    self,\n    model: ModelMetaclass,\n    path: Union[str, list[str]],\n    description: str = None,\n    default=None,\n    **kwargs: dict,\n) -&gt; None:\n    \"\"\"\n    Method to mount pydantic model at provided path in relation to the root model.\n\n    :param model: Pydantic model to mount.\n    :param path: List of path segments to mount the model.\n    :param description: Description of the model.\n    :param default: Default value for the model.\n    :param kwargs: Additional keyword arguments for the FieldInfo.\n    \"\"\"\n    if isinstance(path, str):\n        path = [path.strip()]\n    parent_model = self.root\n    while path:\n        mount_name = path.pop(0)\n        if mount_name in parent_model.model_fields:\n            parent_model = parent_model.model_fields[mount_name].annotation\n        else:\n            # handle when not all path items before last one are in models tree\n            if len(path) &gt; 0:\n                raise KeyError(\n                    f\"'{mount_name}' not part of '{parent_model}' model fields, but remaining path still not empty - {path}\"\n                )\n            parent_model.model_fields[mount_name] = FieldInfo(\n                annotation=model,\n                required=False,\n                description=description,\n                default=default,\n                **kwargs,\n            )\n            break\n</code></pre>"},{"location":"api_reference/#picle.App.model_remove","title":"<code>picle.App.model_remove(path: list[str]) -&gt; None</code>","text":"<p>Method to remove pydantic model at provided path in relation to the root model.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>list[str]</code>)           \u2013            <p>List of path segments to remove the model.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def model_remove(self, path: list[str]) -&gt; None:\n    \"\"\"\n    Method to remove pydantic model at provided path in relation to the root model.\n\n    :param path: List of path segments to remove the model.\n    \"\"\"\n    if isinstance(path, str):\n        path = [path.strip()]\n    parent_model = self.root\n    while path:\n        mount_name = path.pop(0)\n        if mount_name in parent_model.model_fields:\n            if len(path) == 0:\n                parent_model = parent_model.model_fields.pop(mount_name)\n            else:\n                parent_model = parent_model.model_fields[mount_name].annotation\n        else:\n            raise KeyError(\n                f\"Failed to remove model at path '{mount_name}', parent model: '{parent_model}'\"\n            )\n</code></pre>"},{"location":"api_reference/#picle.App.parse_command","title":"<code>picle.App.parse_command(command: str, collect_multiline: bool = False, is_help: bool = False) -&gt; list</code>","text":"<p>Function to parse command string and construct list of model references and fields values.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>command string to parse through</p> </li> <li> <code>is_help</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>indicates that parsing help command or tab completion command, if set to True disables <code>presence</code> argument handling for last field</p> </li> <li> <code>collect_multiline</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>enables multiple input collection for fields</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>returns a list of lists of dictionaries with collected models details each dictionary containing <code>model</code>, <code>fields</code> and <code>parameter</code> keys.</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def parse_command(\n    self, command: str, collect_multiline: bool = False, is_help: bool = False\n) -&gt; list:\n    \"\"\"\n    Function to parse command string and construct list of model\n    references and fields values.\n\n    :param command: command string to parse through\n    :param is_help: indicates that parsing help command or tab completion command,\n        if set to True disables ``presence`` argument handling for last field\n    :param collect_multiline: enables multiple input collection for fields\n    :return: returns a list of lists of dictionaries with collected models details\n        each dictionary containing ``model``, ``fields`` and ``parameter`` keys.\n    \"\"\"\n    current_model = {\n        \"model\": self.shell,\n        \"fields\": [],\n        \"parameter\": ...,\n        \"defaults\": self.extract_model_defaults(self.shell),\n    }\n    current_field = {}\n    models = [current_model]\n    parameters = [i for i in command.split(\" \") if i.strip()]\n    ret = [models]\n\n    # iterate over command parameters and decide if its a reference\n    # to a model or model's field value\n    while parameters:\n        parameter = parameters.pop(0)\n        # handle pipe - \"|\"\n        if parameter == \"|\":\n            # check if current model has pipe defined\n            if hasattr(current_model[\"model\"], \"PicleConfig\") and getattr(\n                current_model[\"model\"].PicleConfig, \"pipe\", None\n            ):\n                if current_model[\"model\"].PicleConfig.pipe == \"self\":\n                    # reference pipe model to current model\n                    current_model = {\n                        \"model\": current_model[\"model\"],\n                        \"fields\": [],\n                        \"parameter\": parameter,\n                    }\n                else:\n                    # goto pipe model\n                    current_model = {\n                        \"model\": current_model[\"model\"].PicleConfig.pipe,\n                        \"fields\": [],\n                        \"parameter\": parameter,\n                    }\n                models = [current_model]\n                ret.append(models)\n            else:\n                log.error(\n                    f\"'{current_model['model'].__name__}' does not support pipe handling\"\n                )\n                break\n        # collect json dictionary string\n        elif parameter.strip().startswith(\"{\") and current_field:\n            value_items = [parameter]\n            # collect further values\n            while parameters:\n                parameter = parameters.pop(0)\n                value_items.append(parameter)\n                if parameter.strip().endswith(\"}\"):\n                    break\n            value = \" \".join(value_items)  # form value string\n            self._save_collected_value(current_field, value)\n        # collect json list string\n        elif parameter.strip().startswith(\"[\") and current_field:\n            value_items = [parameter]\n            # collect further values\n            while parameters:\n                parameter = parameters.pop(0)\n                value_items.append(parameter)\n                if parameter.strip().endswith(\"]\"):\n                    break\n            value = \" \".join(value_items)  # form value string\n            self._save_collected_value(current_field, value)\n        # collect double quoted field value\n        elif '\"' in parameter and current_field:\n            value_items = [parameter.replace('\"', \"\")]\n            # collect further values if first parameter not double quoted value e.g. \"nrp1\"\n            if parameter.count('\"') != 2:\n                while parameters:\n                    parameter = parameters.pop(0)\n                    value_items.append(parameter.replace('\"', \"\"))\n                    if '\"' in parameter:\n                        break\n            value = \" \".join(value_items)  # form value string\n            self._save_collected_value(current_field, value)\n        # collect single quoted field value\n        elif \"'\" in parameter and current_field:\n            value_items = [parameter.replace(\"'\", \"\")]\n            # collect further values if first parameter not double quoted value e.g. 'nrp1'\n            if parameter.count(\"'\") != 2:\n                while parameters:\n                    parameter = parameters.pop(0)\n                    value_items.append(parameter.replace(\"'\", \"\"))\n                    if \"'\" in parameter:\n                        break\n            value = \" \".join(value_items)  # form value string\n            self._save_collected_value(current_field, value)\n        # handle reference to model\n        elif current_model[\"model\"].model_fields.get(parameter) or any(\n            parameter == f.alias\n            for f in current_model[\"model\"].model_fields.values()\n        ):\n            # source field by name\n            if current_model[\"model\"].model_fields.get(parameter):\n                field = current_model[\"model\"].model_fields[parameter]\n            else:\n                # source field by alias\n                for f_name, field in current_model[\"model\"].model_fields.items():\n                    if parameter == field.alias:\n                        parameter = f_name  # use actual field name\n                        break\n            # handle next level model reference\n            if isinstance(field.annotation, ModelMetaclass):\n                # check need to record field presence before going to next model\n                if (\n                    current_field.get(\"values\") is ...\n                    and current_field[\"field\"].json_schema_extra is not None\n                    and \"presence\" in current_field[\"field\"].json_schema_extra\n                ):\n                    value = current_field[\"field\"].json_schema_extra[\"presence\"]\n                    self._save_collected_value(current_field, value)\n                # goto next model\n                current_model = {\n                    \"model\": field.annotation,\n                    \"fields\": [],\n                    \"parameter\": parameter,\n                }\n                models.append(current_model)\n                current_field = {}  # empty current field\n                # extract first command default values from current model\n                if len(ret) == 1:\n                    current_model[\"defaults\"] = self.extract_model_defaults(\n                        field.annotation\n                    )\n            # handle actual field reference\n            elif isinstance(field, FieldInfo):\n                # check need to record field presence before going to next field\n                if (\n                    current_field.get(\"values\") is ...\n                    and current_field[\"field\"].json_schema_extra is not None\n                    and \"presence\" in current_field[\"field\"].json_schema_extra\n                ):\n                    value = current_field[\"field\"].json_schema_extra[\"presence\"]\n                    self._save_collected_value(current_field, value)\n                # goto next field\n                current_field = {\"name\": parameter, \"values\": ..., \"field\": field}\n                # find and replace default value if present\n                for index, field in enumerate(current_model[\"fields\"]):\n                    if field[\"name\"] == current_field[\"name\"]:\n                        current_model[\"fields\"][index] = current_field\n                        break\n                else:\n                    current_model[\"fields\"].append(current_field)\n            else:\n                raise TypeError(\n                    f\"Unsupported pydantic field type: '{type(field.annotation)}', \"\n                    f\"parameter: '{parameter}', command: '{command}', current model: \"\n                    f\"'{current_model['model']}'\"\n                )\n        # check if parameter value partially matches any of the model fields\n        elif any(\n            field_name.startswith(parameter)\n            for field_name in current_model[\"model\"].model_fields\n        ):\n            raise FieldLooseMatchOnly(current_model, parameter)\n        # check if parameter value partially matches any of the model fields' aliases\n        elif any(\n            field.alias.startswith(parameter)\n            for field in current_model[\"model\"].model_fields.values()\n            if field.alias is not None\n        ):\n            raise FieldLooseMatchOnly(current_model, parameter)\n        # parameter is a value, save it to current model\n        elif current_field:\n            self._save_collected_value(current_field, parameter)\n        else:\n            raise FieldKeyError(current_model, parameter)\n    # check presence for last parameter is not is_help\n    if (\n        is_help is False\n        and current_field.get(\"values\") is ...\n        and current_field[\"field\"].json_schema_extra is not None\n        and \"presence\" in current_field[\"field\"].json_schema_extra\n    ):\n        value = current_field[\"field\"].json_schema_extra[\"presence\"]\n        self._save_collected_value(current_field, value)\n\n    # iterate over collected models and fields to see\n    # if need to collect multi-line input\n    if collect_multiline:\n        for command_models in ret:\n            for model in command_models:\n                for field in model[\"fields\"]:\n                    self._collect_multiline(field)\n\n    return ret\n</code></pre>"},{"location":"api_reference/#picle.App.print_model_help","title":"<code>picle.App.print_model_help(models: list, verbose: bool = False, match: str = None, print_help: bool = True) -&gt; None</code>","text":"<p>Function to form and print help message for model fields.</p> <p>Parameters:</p> <ul> <li> <code>match</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>only collect help for fields that start with <code>match</code> string</p> </li> <li> <code>print_help</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if true prints help, return tuple of help lines list and width of longest line</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def print_model_help(\n    self,\n    models: list,\n    verbose: bool = False,\n    match: str = None,\n    print_help: bool = True,\n) -&gt; None:\n    \"\"\"\n    Function to form and print help message for model fields.\n\n    :param match: only collect help for fields that start with ``match`` string\n    :param print_help: if true prints help, return tuple of help lines\n        list and width of longest line\n    \"\"\"\n    model = models[-1][-1]  # get last model\n    last_field = model[\"fields\"][-1] if model[\"fields\"] else None\n    fparam = self._get_field_params(last_field)\n    lines = {}  # dict of {cmd: cmd_help}\n    width = 0  # record longest command width for padding\n    # print help message only for last collected field\n    if last_field and last_field[\"values\"] == ...:\n        field = model[\"model\"].model_fields[last_field[\"name\"]]\n        json_schema_extra = getattr(field, \"json_schema_extra\") or {}\n        name = f\"&lt;'{last_field['name']}' value&gt;\"\n        # check if field is callable\n        if field.annotation is Callable:\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Execute command\"\n            width = max(width, len(name))\n        # check if field referencing function\n        elif json_schema_extra.get(\"function\"):\n            lines[name] = f\"{field.description}\"\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Execute command\"\n            width = max(width, len(name))\n        # add options for enumerations\n        elif isinstance(field.annotation, enum.EnumMeta):\n            options = [i.value for i in field.annotation]\n            lines[name] = \", \".join(options)\n        # check if model has method to source field choices\n        elif hasattr(model[\"model\"], f\"source_{last_field['name']}\"):\n            options = getattr(model[\"model\"], f\"source_{last_field['name']}\")()\n            lines[name] = \", \".join(options)\n        else:\n            lines[name] = f\"{field.description}\"\n            # check if field supports multiline input\n            if fparam.get(\"multiline\") is True:\n                lines[\"input\"] = \"Collect value using multi line input mode\"\n            if verbose:\n                lines[name] += (\n                    f\"; default '{field.get_default()}', type '{str(field.annotation)}', \"\n                    f\"is required - {field.is_required()}\"\n                )\n    # collect help message for all fields of this model\n    else:\n        # check if model supports subshell\n        if (\n            hasattr(model[\"model\"], \"PicleConfig\")\n            and getattr(model[\"model\"].PicleConfig, \"subshell\", None) is True\n            # exclude &lt;ENTER&gt; if already in model's shell\n            and not self.shells[-1] == model[\"model\"]\n        ):\n            name = \"&lt;ENTER&gt;\"\n            lines[name] = \"Enter command subshell\"\n            width = max(width, len(name))\n        # iterate over model fields\n        for name, field in model[\"model\"].model_fields.items():\n            # skip fields that already have values\n            if any(f[\"name\"] == name for f in model[\"fields\"]):\n                continue\n            # check if field has alias\n            if field.alias:\n                name = field.alias\n            # filter fields\n            if match and not name.startswith(match):\n                continue\n            lines[name] = f\"{field.description}\"\n            if verbose:\n                lines[name] += (\n                    f\"; default '{field.get_default()}', type '{str(field.annotation)}', \"\n                    f\"is required - {field.is_required()}\"\n                )\n            width = max(width, len(name))\n    # check if model has pipe defined\n    if hasattr(model[\"model\"], \"PicleConfig\") and getattr(\n        model[\"model\"].PicleConfig, \"pipe\", None\n    ):\n        name = \"|\"\n        lines[name] = \"Execute pipe command\"\n        width = max(width, len(name))\n    width = max(width, len(name))\n    # form help lines\n    help_msg = []\n    for k in sorted(lines.keys()):\n        padding = \" \" * (width - len(k)) + (\" \" * 4)\n        help_msg.append(f\" {k}{padding}{lines[k]}\")\n\n    if print_help:  # print help message\n        self.write(self.newline.join(help_msg))\n    else:\n        return help_msg, width\n</code></pre>"},{"location":"api_reference/#picle.App.write","title":"<code>picle.App.write(text: str) -&gt; None</code>","text":"<p>Method to write output to stdout</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>text output</p> </li> </ul> Source code in <code>picle\\picle.py</code> <pre><code>def write(self, text: str) -&gt; None:\n    \"\"\"\n    Method to write output to stdout\n\n    :param text: text output\n    \"\"\"\n    if not isinstance(text, str):\n        text = str(text)\n    if not text.endswith(self.newline):\n        self.stdout.write(text + self.newline)\n    else:\n        self.stdout.write(text)\n</code></pre>"},{"location":"api_reference/#picle-build-in-models","title":"PICLE Build In Models","text":""},{"location":"api_reference/#picle.models.Filters","title":"<code>picle.models.Filters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Filters.filter_exclude","title":"<code>picle.models.Filters.filter_exclude(data: Any, exclude: Any = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Filter data line by line using provided pattern. Returns only lines that does not contains requested <code>exclude</code> pattern.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>data to filter</p> </li> <li> <code>exclude</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>pattern to filter data</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef filter_exclude(data: Any, exclude: Any = None) -&gt; str:\n    \"\"\"\n    Filter data line by line using provided pattern. Returns\n    only lines that does not contains requested ``exclude`` pattern.\n\n    :param data: data to filter\n    :param exclude: pattern to filter data\n    \"\"\"\n    exclude = str(exclude)\n    return \"\\n\".join(\n        [line for line in str(data).splitlines() if exclude not in line]\n    )\n</code></pre>"},{"location":"api_reference/#picle.models.Filters.filter_include","title":"<code>picle.models.Filters.filter_include(data: Any, include: Any = None) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Filter data line by line using provided pattern. Returns only lines that contains requested <code>include</code> pattern.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>data to filter</p> </li> <li> <code>include</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>pattern to filter data</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef filter_include(data: Any, include: Any = None) -&gt; str:\n    \"\"\"\n    Filter data line by line using provided pattern. Returns\n    only lines that contains requested ``include`` pattern.\n\n    :param data: data to filter\n    :param include: pattern to filter data\n    \"\"\"\n    include = str(include)\n    return \"\\n\".join([line for line in str(data).splitlines() if include in line])\n</code></pre>"},{"location":"api_reference/#picle.models.Formatters","title":"<code>picle.models.Formatters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Formatters.formatter_json","title":"<code>picle.models.Formatters.formatter_json(data: Any) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Function to transform results into JSON string</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to convert</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef formatter_json(data: Any) -&gt; str:\n    \"\"\"\n    Function to transform results into JSON string\n\n    :param data: any data to convert\n    \"\"\"\n    return json.dumps(data, indent=4, sort_keys=True)\n</code></pre>"},{"location":"api_reference/#picle.models.Formatters.formatter_kv","title":"<code>picle.models.Formatters.formatter_kv(data: dict) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Function to format dictionary result as a key: value output</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>dictionary to format</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef formatter_kv(data: dict) -&gt; str:\n    \"\"\"\n    Function to format dictionary result as a key: value output\n\n    :param data: dictionary to format\n    \"\"\"\n    return \"\\n\".join([f\" {k}: {v}\" for k, v in data.items()])\n</code></pre>"},{"location":"api_reference/#picle.models.Formatters.formatter_pprint","title":"<code>picle.models.Formatters.formatter_pprint(data: Any) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Function to pretty print results using python <code>pprint</code> module</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to pretty print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef formatter_pprint(data: Any) -&gt; str:\n    \"\"\"\n    Function to pretty print results using python ``pprint`` module\n\n    :param data: any data to pretty print\n    \"\"\"\n    return pprint.pformat(data, indent=4)\n</code></pre>"},{"location":"api_reference/#picle.models.Formatters.formatter_yaml","title":"<code>picle.models.Formatters.formatter_yaml(data: Any) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Function to transform results into YAML string</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to convert</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef formatter_yaml(data: Any) -&gt; str:\n    \"\"\"\n    Function to transform results into YAML string\n\n    :param data: any data to convert\n    \"\"\"\n    if HAS_YAML:\n        return yaml_dump(data, default_flow_style=False)\n    else:\n        return data\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters","title":"<code>picle.models.Outputters</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_json","title":"<code>picle.models.Outputters.outputter_rich_json(data: Union[dict, list]) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Function to pretty print JSON string using Rich library</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Union[dict, list]</code>)           \u2013            <p>any data to print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_json(data: Union[dict, list]) -&gt; None:\n    \"\"\"\n    Function to pretty print JSON string using Rich library\n\n    :param data: any data to print\n    \"\"\"\n    if isinstance(data, bytes):\n        data = data.decode(\"utf-8\")\n\n    if not isinstance(data, str):\n        data = json.dumps(data)\n\n    # data should be a json string\n    try:\n        if HAS_RICH:\n            RICHCONSOLE.print_json(data, sort_keys=True, indent=4)\n        else:\n            print(data)\n    except Exception as e:\n        print(f\"ERROR: Data is not a valid JSON string:\\n{data}\\n\\nError: '{e}'\")\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_print","title":"<code>picle.models.Outputters.outputter_rich_print(data: Any) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Function to pretty print output using Rich library</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>any data to print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_print(data: Any) -&gt; None:\n    \"\"\"\n    Function to pretty print output using Rich library\n\n    :param data: any data to print\n    \"\"\"\n    if HAS_RICH:\n        RICHCONSOLE.print(data)\n    else:\n        print(data)\n</code></pre>"},{"location":"api_reference/#picle.models.Outputters.outputter_rich_table","title":"<code>picle.models.Outputters.outputter_rich_table(data: list[dict], headers: list = None, title: str = None, sortby: str = None)</code>  <code>staticmethod</code>","text":"<p>Function to pretty print output in table format using Rich library</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>list[dict]</code>)           \u2013            <p>list of dictionaries to print</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef outputter_rich_table(\n    data: list[dict], headers: list = None, title: str = None, sortby: str = None\n):\n    \"\"\"\n    Function to pretty print output in table format using Rich library\n\n    :param data: list of dictionaries to print\n    \"\"\"\n    if not HAS_RICH or not isinstance(data, list):\n        print(data)\n        return\n\n    headers = headers or list(data[0].keys())\n    table = RICHTABLE(title=title, box=False)\n\n    # add table columns\n    for h in headers:\n        table.add_column(h, justify=\"left\", no_wrap=True)\n\n    # sort the table\n    if sortby:\n        # form dictionary keyed by sortby value and index\n        items_to_sortby = {i[sortby]: index for index, i in enumerate(data)}\n        # form a list of sorted sortby values\n        sorted_keys = sorted(items_to_sortby.keys())\n        # for sorted data list\n        sorted_data = [data[items_to_sortby[key]] for key in sorted_keys]\n    else:\n        sorted_data = data\n\n    # add table rows\n    for item in sorted_data:\n        cells = [item.get(h, \"\") for h in headers]\n        table.add_row(*cells)\n\n    RICHCONSOLE.print(table)\n</code></pre>"},{"location":"api_reference/#picle.models.PipeFunctionsModel","title":"<code>picle.models.PipeFunctionsModel</code>","text":"<p>               Bases: <code>Filters</code>, <code>Formatters</code>, <code>Outputters</code></p> <p>Collection of common pipe functions to use in PICLE shell models</p>"},{"location":"api_reference/#picle.models.MAN","title":"<code>picle.models.MAN</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model with manual/documentation related functions</p>"},{"location":"api_reference/#picle.models.MAN.print_model_tree","title":"<code>picle.models.MAN.print_model_tree(root_model, **kwargs) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Method to print model tree for shell model specified by dot separated path e.g. model.shell.command</p> <p>Parameters:</p> <ul> <li> <code>root_model</code>           \u2013            <p>PICLE App root model to print tree for</p> </li> </ul> Source code in <code>picle\\models.py</code> <pre><code>@staticmethod\ndef print_model_tree(root_model, **kwargs) -&gt; None:\n    \"\"\"\n    Method to print model tree for shell model specified by dot separated path e.g. model.shell.command\n\n    :param root_model: PICLE App root model to print tree for\n    \"\"\"\n    path = kwargs[\"tree\"].split(\".\") if kwargs.get(\"tree\") else []\n    rich_tree = RICHTREE(\"[bold]root[/bold]\")\n    RICHCONSOLE.print(\n        MAN._construct_model_tree(\n            model=root_model.model_construct(), tree=rich_tree, path=path\n        )\n    )\n</code></pre>"}]}